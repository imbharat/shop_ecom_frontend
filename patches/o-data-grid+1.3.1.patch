diff --git a/node_modules/o-data-grid/build/o-data-grid-esm.js b/node_modules/o-data-grid/build/o-data-grid-esm.js
index b174ce2..3f396e7 100644
--- a/node_modules/o-data-grid/build/o-data-grid-esm.js
+++ b/node_modules/o-data-grid/build/o-data-grid-esm.js
@@ -1,1219 +1 @@
-import { jsxs, jsx } from 'react/jsx-runtime';
-import React, { useEffect, useState, useMemo, Fragment, useCallback, useRef } from 'react';
-import { Box } from '@mui/system';
-import { useTheme } from '@mui/material/styles';
-import { atom, useRecoilValue, useRecoilState, useSetRecoilState, waitForAll, RecoilRoot } from 'recoil';
-import { Remove, Add, ArrowDropDown } from '@mui/icons-material';
-import { Grid, Autocomplete, TextField, FormControl, InputLabel, Select, MenuItem, IconButton, useTheme as useTheme$1, ToggleButtonGroup, ToggleButton, ButtonGroup, Button, Popover, Paper, MenuList } from '@mui/material';
-import Immutable from 'immutable';
-import { LocalizationProvider, DatePicker, DateTimePicker } from '@mui/x-date-pickers';
-import { v4 } from 'uuid';
-import { createMakeStyles } from 'tss-react';
-import { DataGrid } from '@mui/x-data-grid';
-
-/******************************************************************************
-Copyright (c) Microsoft Corporation.
-
-Permission to use, copy, modify, and/or distribute this software for any
-purpose with or without fee is hereby granted.
-
-THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
-AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
-INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
-LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
-OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
-PERFORMANCE OF THIS SOFTWARE.
-***************************************************************************** */
-
-function __awaiter(thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-}
-
-const useResponsive = () => {
-    const theme = useTheme();
-    const matches = useBreakpoints();
-    return function (responsiveValues) {
-        let match;
-        theme.breakpoints.keys.forEach((breakpoint) => {
-            if (matches[breakpoint] && responsiveValues[breakpoint] != null) {
-                match = breakpoint;
-            }
-        });
-        return match && responsiveValues[match];
-    };
-};
-// eslint-disable-next-line react-hooks/exhaustive-deps
-const useMountEffect = (func) => useEffect(func, []);
-const useBreakpoints = () => {
-    const theme = useTheme();
-    const [matches, setMatches] = useState(getMatches(theme.breakpoints.keys, theme));
-    useEffect(() => {
-        const queries = getQueries(theme.breakpoints.keys, theme);
-        const listeners = {};
-        const updateMatch = (b) => {
-            setMatches((oldMatches) => { var _a, _b; return (Object.assign(Object.assign({}, oldMatches), { [b]: (_b = (_a = queries[b]) === null || _a === void 0 ? void 0 : _a.matches) !== null && _b !== void 0 ? _b : false })); });
-        };
-        theme.breakpoints.keys.forEach(b => {
-            listeners[b] = () => updateMatch(b);
-            queries[b].addEventListener("change", listeners[b]);
-        });
-        return () => {
-            theme.breakpoints.keys.forEach(b => {
-                queries[b].removeEventListener("change", listeners[b]);
-            });
-        };
-    }, [theme]);
-    return matches;
-};
-const getQueries = (breakpoints, theme) => breakpoints.reduce((acc, b) => (Object.assign(Object.assign({}, acc), { [b]: window.matchMedia(theme.breakpoints.up(b).replace(/^@media( ?)/m, '')) })), {});
-const getMatches = (breakpoints, theme) => breakpoints.reduce((acc, b) => (Object.assign(Object.assign({}, acc), { [b]: window.matchMedia(theme.breakpoints.up(b).replace(/^@media( ?)/m, '')).matches })), {});
-
-const rootGroupUuid = "17c63a07-397b-4f03-a74b-2f935dcc6c8a";
-const rootConditionUuid = "18c1713a-2480-40c0-b60f-220a3fd4b117";
-const allOperators = ["eq", "ne", "gt", "lt", "ge", "le", "contains", "null", "notnull"];
-const numericOperators = ["eq", "ne", "gt", "lt", "ge", "le"];
-const initialClauses = Immutable.Map({
-    [rootGroupUuid]: {
-        id: rootGroupUuid,
-        connective: "and"
-    },
-    [rootConditionUuid]: {
-        id: rootConditionUuid,
-        field: "",
-        op: "eq",
-        value: null,
-        default: true
-    }
-});
-const initialTree = Immutable.Map({
-    [rootGroupUuid]: {
-        id: rootGroupUuid,
-        children: Immutable.Map({ [rootConditionUuid]: rootConditionUuid })
-    }
-});
-const defaultLocale = {
-    and: "And",
-    or: "Or",
-    addCondition: "Add Condition",
-    addGroup: "Add Group",
-    field: "Field",
-    operation: "Operation",
-    value: "Value",
-    collectionOperation: "Operation",
-    collectionField: "Field",
-    search: "Search",
-    reset: "Reset",
-    opAny: "Has at least one",
-    opAll: "All have",
-    opCount: "Count",
-    opEq: "=",
-    opNe: "≠",
-    opGt: ">",
-    opLt: "<",
-    opGe: "≥",
-    opLe: "≤",
-    opContains: "Contains",
-    opNull: "Is Blank",
-    opNotNull: "Is Not Blank"
-};
-
-const schemaState = atom({
-    key: "schema",
-    default: []
-});
-const clauseState = atom({
-    key: "filterClauses",
-    default: initialClauses
-});
-const treeState = atom({
-    key: "filterTree",
-    default: initialTree
-});
-const propsState = atom({
-    key: "props",
-    default: {}
-});
-
-const getDefaultCondition = (field) => ({
-    field: field,
-    op: "eq",
-    value: null,
-    id: v4()
-});
-const getDefaultGroup = () => ({
-    connective: "and",
-    id: v4()
-});
-const getSelectOption = (option) => {
-    if (typeof option === "string") {
-        return { value: option, label: option };
-    }
-    else if (typeof option === "number") {
-        return { value: option.toString(), label: option.toString() };
-    }
-    else {
-        return option;
-    }
-};
-const getLocaleText = (key, locale) => locale !== undefined && locale[key] ? locale[key] : defaultLocale[key];
-const deserialise = (obj) => {
-    const [treeGroup, clauses] = groupObjToMap(obj, rootGroupUuid);
-    return [
-        Immutable.Map({
-            [rootGroupUuid]: treeGroup
-        }),
-        clauses
-    ];
-};
-const groupObjToMap = (obj, id, clauses) => {
-    let children = Immutable.Map();
-    if (!clauses) {
-        clauses = Immutable.Map();
-    }
-    clauses = clauses.set(id, Object.assign({ id: id }, obj));
-    obj.children.forEach((child) => {
-        const childId = v4();
-        clauses = clauses.set(childId, Object.assign({ id: childId }, child));
-        const g = child;
-        if (g.connective) {
-            const result = groupObjToMap(g, childId, clauses);
-            children = children.set(childId, result[0]);
-            clauses = clauses.merge(result[1]);
-        }
-        else {
-            children = children.set(childId, childId);
-        }
-    });
-    return [{ id: id, children: children }, clauses];
-};
-const escapeODataString = (val) => val.replace("'", "''");
-
-const FilterInputs = ({ clauseId, field, onFieldChange, op, onOpChange, value, onValueChange, collectionOp, onCollectionOpChange, collectionField, onCollectionFieldChange }) => {
-    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
-    const schema = useRecoilValue(schemaState);
-    const builderProps = useRecoilValue(propsState);
-    const dateAdapter = useMemo(() => { var _a; return (_a = builderProps.localizationProviderProps) === null || _a === void 0 ? void 0 : _a.dateAdapter; }, [builderProps]);
-    const fieldDef = useMemo(() => {
-        var _a, _b, _c, _d, _e, _f, _g;
-        if (!field && schema.length < 1) {
-            return null;
-        }
-        let f;
-        if (field) {
-            f = (_a = schema.find(c => c.field === field)) !== null && _a !== void 0 ? _a : schema[0];
-        }
-        else {
-            f = schema[0];
-        }
-        if (!f) {
-            return null;
-        }
-        let filterField = field;
-        let colField;
-        let type = (_b = f.filterType) !== null && _b !== void 0 ? _b : f.type;
-        let options = f.valueOptions;
-        let ops = (_c = f.filterOperators) !== null && _c !== void 0 ? _c : allOperators;
-        if (f.collection === true && f.collectionFields) {
-            if (collectionField) {
-                colField = (_d = f.collectionFields.find(c => c.field === collectionField)) !== null && _d !== void 0 ? _d : f.collectionFields[0];
-            }
-            else {
-                colField = f.collectionFields[0];
-            }
-            filterField = colField.field;
-            type = colField.type;
-            options = colField.valueOptions;
-            if (collectionOp !== "count") {
-                ops = (_e = colField.filterOperators) !== null && _e !== void 0 ? _e : allOperators;
-            }
-            else {
-                ops = numericOperators;
-                type = "number";
-            }
-        }
-        // get value options into a single type
-        let valueOptions;
-        if (type === "singleSelect" && typeof options === "function") {
-            valueOptions = options({ field: filterField }).map((v) => getSelectOption(v));
-        }
-        else if (type === "singleSelect" && options) {
-            valueOptions = options.map((v) => getSelectOption(v));
-        }
-        return Object.assign(Object.assign({}, f), { fieldLabel: (_g = (_f = f.label) !== null && _f !== void 0 ? _f : f.headerName) !== null && _g !== void 0 ? _g : f.field, type: type, ops: ops, valueOptions: valueOptions, colField: colField });
-    }, [field, collectionField, collectionOp, schema]);
-    const fieldOptions = useMemo(() => schema
-        .filter(c => c.filterable !== false)
-        .map(c => { var _a, _b, _c; return ({ label: (_b = (_a = c.label) !== null && _a !== void 0 ? _a : c.headerName) !== null && _b !== void 0 ? _b : c.field, field: c.field, group: (_c = c.autocompleteGroup) !== null && _c !== void 0 ? _c : "" }); })
-        .sort((a, b) => builderProps.autocompleteGroups ?
-        builderProps.autocompleteGroups.indexOf(a.group) - builderProps.autocompleteGroups.indexOf(b.group)
-        : a.group.localeCompare(b.group)), [schema, builderProps]);
-    if (schema.length < 1 || !fieldDef) {
-        return null;
-    }
-    return (jsxs(Fragment, { children: [jsx(Grid, Object.assign({ item: true, xs: 12, md: fieldDef.collection ? true : 4 }, { children: jsx(Autocomplete, Object.assign({ size: "small" }, builderProps.autocompleteProps, { options: fieldOptions, renderInput: (params) => jsx(TextField, Object.assign({ label: getLocaleText("field", builderProps.localeText) }, builderProps.textFieldProps, params)), value: { label: fieldDef.fieldLabel, field: fieldDef.field, group: fieldDef.autocompleteGroup }, onChange: (_, val) => onFieldChange(fieldDef.field, op, val.field), disableClearable: true, isOptionEqualToValue: (option, value) => option.field === value.field, groupBy: (option) => option.group })) })), fieldDef.collection === true &&
-                jsx(Grid, Object.assign({ item: true, xs: 12, md: true }, { children: jsxs(FormControl, Object.assign({ fullWidth: true, size: "small" }, { children: [jsx(InputLabel, Object.assign({ id: `${clauseId}_label-collection-op` }, { children: getLocaleText("collectionOperation", builderProps.localeText) })), jsxs(Select, Object.assign({ label: getLocaleText("collectionOperation", builderProps.localeText) }, builderProps.selectProps, { value: collectionOp, onChange: (e) => onCollectionOpChange(e.target.value), labelId: `${clauseId}_label-collection-op` }, { children: [jsx(MenuItem, Object.assign({ value: "any" }, { children: getLocaleText("opAny", builderProps.localeText) })), jsx(MenuItem, Object.assign({ value: "all" }, { children: getLocaleText("opAll", builderProps.localeText) })), jsx(MenuItem, Object.assign({ value: "count" }, { children: getLocaleText("opCount", builderProps.localeText) }))] }))] })) })), fieldDef.collection === true && collectionOp !== "count" &&
-                jsx(Grid, Object.assign({ item: true, xs: 12, md: true }, { children: jsx(Autocomplete, Object.assign({ size: "small" }, builderProps.autocompleteProps, { options: (_b = (_a = fieldDef.collectionFields) === null || _a === void 0 ? void 0 : _a.map(c => ({ label: c.label, field: c.field }))) !== null && _b !== void 0 ? _b : [], renderInput: (params) => jsx(TextField, Object.assign({ label: getLocaleText("collectionField", builderProps.localeText) }, builderProps.textFieldProps, params)), value: { label: (_c = fieldDef.colField) === null || _c === void 0 ? void 0 : _c.label, field: collectionField }, onChange: (_, val) => onCollectionFieldChange(field, collectionField, op, val.field), disableClearable: true, isOptionEqualToValue: (option, value) => option.field === value.field })) })), fieldDef.renderCustomFilter ?
-                fieldDef.renderCustomFilter(value, onValueChange)
-                :
-                    jsx(Grid, Object.assign({ item: true, xs: 12, md: true }, { children: jsxs(FormControl, Object.assign({ fullWidth: true, size: "small" }, { children: [jsx(InputLabel, Object.assign({ id: `${clauseId}_label-op` }, { children: "Operation" })), jsxs(Select, Object.assign({}, builderProps.selectProps, { value: op, onChange: (e) => onOpChange(e.target.value), labelId: `${clauseId}_label-op`, label: "Operation" }, { children: [jsx(MenuItem, Object.assign({ value: "eq", disabled: !fieldDef.ops.includes("eq") }, { children: getLocaleText("opEq", builderProps.localeText) })), jsx(MenuItem, Object.assign({ value: "ne", disabled: !fieldDef.ops.includes("ne") }, { children: getLocaleText("opNe", builderProps.localeText) })), jsx(MenuItem, Object.assign({ value: "gt", disabled: !fieldDef.ops.includes("gt") }, { children: getLocaleText("opGt", builderProps.localeText) })), jsx(MenuItem, Object.assign({ value: "lt", disabled: !fieldDef.ops.includes("lt") }, { children: getLocaleText("opLt", builderProps.localeText) })), jsx(MenuItem, Object.assign({ value: "ge", disabled: !fieldDef.ops.includes("ge") }, { children: getLocaleText("opGe", builderProps.localeText) })), jsx(MenuItem, Object.assign({ value: "le", disabled: !fieldDef.ops.includes("le") }, { children: getLocaleText("opLe", builderProps.localeText) })), jsx(MenuItem, Object.assign({ value: "contains", disabled: !fieldDef.ops.includes("contains") }, { children: getLocaleText("opContains", builderProps.localeText) })), jsx(MenuItem, Object.assign({ value: "null", disabled: !fieldDef.ops.includes("null") }, { children: getLocaleText("opNull", builderProps.localeText) })), jsx(MenuItem, Object.assign({ value: "notnull", disabled: !fieldDef.ops.includes("notnull") }, { children: getLocaleText("opNotNull", builderProps.localeText) }))] }))] })) })), !fieldDef.renderCustomFilter &&
-                jsx(Grid, Object.assign({ item: true, xs: true }, { children: op !== "null" && op !== "notnull" &&
-                        (fieldDef.renderCustomInput ? fieldDef.renderCustomInput(value, onValueChange) :
-                            jsxs(Fragment, { children: [fieldDef.type === "date" &&
-                                        jsx(LocalizationProvider, Object.assign({ dateAdapter: dateAdapter }, builderProps.localizationProviderProps, { children: jsx(DatePicker, Object.assign({ label: getLocaleText("value", builderProps.localeText) }, builderProps.datePickerProps, fieldDef.datePickerProps, { value: value !== null && value !== void 0 ? value : "", renderInput: (params) => jsx(TextField, Object.assign({ fullWidth: true, size: "small" }, builderProps.textFieldProps, fieldDef.textFieldProps, params)), onChange: (date) => onValueChange(new dateAdapter().formatByString(date, "YYYY-MM-DD")) })) })), fieldDef.type === "datetime" &&
-                                        jsx(LocalizationProvider, Object.assign({ dateAdapter: dateAdapter }, builderProps.localizationProviderProps, { children: jsx(DateTimePicker, Object.assign({ label: getLocaleText("value", builderProps.localeText) }, fieldDef.dateTimePickerProps, { value: value !== null && value !== void 0 ? value : "", renderInput: (params) => jsx(TextField, Object.assign({ fullWidth: true, size: "small" }, builderProps.textFieldProps, fieldDef.textFieldProps, params)), onChange: (date) => onValueChange(new dateAdapter().toISO(date)) })) })), fieldDef.type === "boolean" &&
-                                        jsxs(FormControl, Object.assign({ fullWidth: true, size: "small" }, (_d = fieldDef.selectProps) === null || _d === void 0 ? void 0 : _d.formControlProps, { children: [jsx(InputLabel, Object.assign({ id: `${clauseId}_label-bool-value` }, { children: (_f = (_e = fieldDef.selectProps) === null || _e === void 0 ? void 0 : _e.label) !== null && _f !== void 0 ? _f : getLocaleText("value", builderProps.localeText) })), jsxs(Select, Object.assign({ label: (_h = (_g = fieldDef.selectProps) === null || _g === void 0 ? void 0 : _g.label) !== null && _h !== void 0 ? _h : getLocaleText("value", builderProps.localeText) }, builderProps.selectProps, (_j = fieldDef.selectProps) === null || _j === void 0 ? void 0 : _j.selectProps, { value: value !== null && value !== void 0 ? value : true, onChange: (e) => onValueChange(e.target.value), labelId: `${clauseId}_label-bool-value` }, { children: [jsx(MenuItem, Object.assign({ value: "true" }, { children: "Yes" })), jsx(MenuItem, Object.assign({ value: "false" }, { children: "No" })), fieldDef.nullable && jsx(MenuItem, Object.assign({ value: "null" }, { children: "Unknown" }))] }))] })), fieldDef.type === "singleSelect" && fieldDef.valueOptions &&
-                                        jsxs(FormControl, Object.assign({ fullWidth: true, size: "small" }, (_k = fieldDef.selectProps) === null || _k === void 0 ? void 0 : _k.formControlProps, { children: [jsx(InputLabel, Object.assign({ id: `${clauseId}_label-select-value` }, { children: (_m = (_l = fieldDef.selectProps) === null || _l === void 0 ? void 0 : _l.label) !== null && _m !== void 0 ? _m : getLocaleText("value", builderProps.localeText) })), jsx(Select, Object.assign({ label: (_p = (_o = fieldDef.selectProps) === null || _o === void 0 ? void 0 : _o.label) !== null && _p !== void 0 ? _p : getLocaleText("value", builderProps.localeText), value: value !== null && value !== void 0 ? value : "", onChange: (e) => onValueChange(e.target.value), labelId: `${clauseId}_label-select-value` }, { children: fieldDef.valueOptions.map((o, i) => (jsx(MenuItem, Object.assign({ value: o.value }, { children: o.label }), `${clauseId}_${field}_select_${i}`))) }))] })), (!fieldDef.type || fieldDef.type === "string" || fieldDef.type === "number") &&
-                                        jsx(TextField, Object.assign({ size: "small", fullWidth: true, label: getLocaleText("value", builderProps.localeText) }, builderProps.textFieldProps, fieldDef.textFieldProps, { value: value !== null && value !== void 0 ? value : "", onChange: (e) => onValueChange(fieldDef.type === "number" ? parseFloat(e.target.value) : e.target.value), type: fieldDef.type === "number" ? "number" : "text" }))] })) }))] }));
-};
-var FilterInputs$1 = React.memo(FilterInputs);
-
-const FilterCondition = ({ clauseId, path }) => {
-    const [clauses, setClauses] = useRecoilState(clauseState);
-    const setTree = useSetRecoilState(treeState);
-    const schema = useRecoilValue(schemaState);
-    const condition = useMemo(() => clauses.get(clauseId), [clauses, clauseId]);
-    const changeField = useCallback((oldField, currentOp, newField) => {
-        const oldFieldDef = schema.find(c => c.field === oldField);
-        const newFieldDef = schema.find(c => c.field === newField);
-        setClauses(old => old.update(clauseId, c => {
-            var _a;
-            const condition = Object.assign({}, c);
-            condition.field = newField;
-            condition.default = false;
-            if (oldFieldDef && newFieldDef) {
-                // reset value if fields have different types
-                if (oldFieldDef.type !== newFieldDef.type) {
-                    condition.value = "";
-                }
-                // reset operator if new field doesn't support current operator
-                if (newFieldDef.filterOperators && !newFieldDef.filterOperators.includes(currentOp)) {
-                    condition.op = (_a = newFieldDef.filterOperators[0]) !== null && _a !== void 0 ? _a : "eq";
-                }
-                // set collection field if new field is a collection
-                if (newFieldDef.collection === true && newFieldDef.collectionFields) {
-                    condition.collectionField = newFieldDef.collectionFields[0].field;
-                    condition.collectionOp = "any";
-                    if (newFieldDef.collectionFields[0].filterOperators) {
-                        condition.op = newFieldDef.collectionFields[0].filterOperators[0];
-                    }
-                    else {
-                        condition.op = "eq";
-                    }
-                }
-                else { // clear collection fields if new field is not a collection
-                    condition.collectionField = undefined;
-                    condition.collectionOp = undefined;
-                }
-            }
-            return condition;
-        }));
-    }, [schema, setClauses, clauseId]);
-    const changeOp = useCallback((o) => {
-        setClauses(old => old.update(clauseId, c => (Object.assign(Object.assign({}, c), { op: o, default: false }))));
-    }, [setClauses, clauseId]);
-    const changeValue = useCallback((v) => {
-        setClauses(old => old.update(clauseId, c => (Object.assign(Object.assign({}, c), { value: v, default: false }))));
-    }, [setClauses, clauseId]);
-    const changeCollectionOp = useCallback((o) => {
-        setClauses(old => old.update(clauseId, c => {
-            const condition = Object.assign(Object.assign({}, c), { collectionOp: o, default: false });
-            // reset field operator if switching to count operator and current op is not valid
-            if (o === "count" && !numericOperators.includes(condition.op)) {
-                condition.op = "eq";
-            }
-            return condition;
-        }));
-    }, [setClauses, clauseId]);
-    const changeCollectionField = useCallback((field, oldColField, currentOp, newColField) => {
-        const fieldDef = schema.find(c => c.field === field);
-        setClauses(old => old.update(clauseId, c => {
-            var _a;
-            const condition = Object.assign({}, c);
-            condition.collectionField = newColField;
-            condition.default = false;
-            if (fieldDef && fieldDef.collectionFields && oldColField && newColField) {
-                const oldColFieldDef = fieldDef.collectionFields.find(c => c.field === oldColField);
-                const newColFieldDef = fieldDef.collectionFields.find(c => c.field === newColField);
-                // reset value if fields have different types
-                if (oldColFieldDef.type !== newColFieldDef.type) {
-                    condition.value = "";
-                }
-                // reset operator if new field doesn't support current operator
-                if (newColFieldDef.filterOperators && !newColFieldDef.filterOperators.includes(currentOp)) {
-                    condition.op = (_a = newColFieldDef.filterOperators[0]) !== null && _a !== void 0 ? _a : "eq";
-                }
-            }
-            return condition;
-        }));
-    }, [schema, setClauses, clauseId]);
-    const remove = useCallback(() => {
-        // if not root group
-        if (path.length > 2) {
-            setTree(oldTree => oldTree.withMutations((old) => {
-                // delete self
-                old.deleteIn([...path, clauseId]);
-                // get path to parent node (i.e. remove "children" from end of path)
-                const parentPath = [...path];
-                parentPath.splice(-1, 1);
-                do {
-                    const node = old.getIn(parentPath);
-                    // delete parent if now empty
-                    if (node && node.children.count() < 1) {
-                        old.deleteIn(parentPath);
-                    }
-                    else { // not the only child, so only remove self and stop
-                        old.deleteIn([...path, clauseId]);
-                        break;
-                    }
-                    parentPath.splice(-2, 2); // move up in path to next parent
-                } while (parentPath.length > 2); // keep removing empty groups until root is reached
-            }));
-        }
-        else {
-            setTree(old => old.deleteIn([...path, clauseId]));
-        }
-        setClauses(old => old.remove(clauseId));
-    }, [setClauses, setTree, clauseId, path]);
-    if (!condition) {
-        return null;
-    }
-    return (jsxs(Grid, Object.assign({ container: true, spacing: 1 }, { children: [jsx(FilterInputs$1, { clauseId: clauseId, field: condition.field, onFieldChange: changeField, op: condition.op, onOpChange: changeOp, value: condition.value, onValueChange: changeValue, collectionOp: condition.collectionOp, onCollectionOpChange: changeCollectionOp, collectionField: condition.collectionField, onCollectionFieldChange: changeCollectionField }), jsx(Grid, Object.assign({ item: true, xs: "auto" }, { children: jsx(IconButton, Object.assign({ onClick: remove }, { children: jsx(Remove, {}) })) }))] })));
-};
-
-const { makeStyles } = createMakeStyles({ useTheme: useTheme$1 });
-
-const useStyles = makeStyles()((theme) => ({
-    group: {
-        borderWidth: 1,
-        borderColor: theme.palette.mode === "dark" ? "rgb(81,81,81)" : "rgb(224,224,224)",
-        borderRadius: theme.shape.borderRadius,
-        borderStyle: "solid",
-        padding: theme.spacing(2),
-    },
-    child: {
-        position: "relative",
-        "&:not(:last-of-type)::before": {
-            content: "''",
-            display: "block",
-            position: "absolute",
-            width: 2,
-            height: "100%",
-            background: theme.palette.primary.main,
-            left: theme.spacing(-1),
-        },
-        "&:first-of-type::before": {
-            height: `calc(100% + ${theme.spacing(2)})`,
-            top: 0
-        },
-        "&::after": {
-            content: "''",
-            display: "block",
-            position: "absolute",
-            left: theme.spacing(-1),
-            top: `calc(${theme.spacing(1)} + 1px)`,
-            width: theme.spacing(2),
-            height: "50%",
-            borderWidth: 2,
-            borderStyle: "solid",
-            borderColor: theme.palette.primary.main,
-            borderRight: "none",
-            borderTop: "none",
-            borderBottomLeftRadius: theme.shape.borderRadius
-        }
-    }
-}));
-const FilterGroup = ({ clauseId, path, root }) => {
-    const { classes } = useStyles();
-    const r = useResponsive();
-    const [tree, clauses] = useRecoilValue(waitForAll([treeState, clauseState]));
-    const setTree = useSetRecoilState(treeState);
-    const setClauses = useSetRecoilState(clauseState);
-    const schema = useRecoilValue(schemaState);
-    const builderProps = useRecoilValue(propsState);
-    const group = useMemo(() => clauses.get(clauseId), [clauses, clauseId]);
-    const treeGroup = useMemo(() => tree.getIn([...path, clauseId]), [tree, path, clauseId]);
-    const childrenPath = useMemo(() => [...path, clauseId, "children"], [path, clauseId]);
-    const multiple = useMemo(() => treeGroup.children.count() > 1, [treeGroup]);
-    const setConnective = useCallback((con) => {
-        setClauses(clauses.update(clauseId, c => (Object.assign(Object.assign({}, c), { connective: con }))));
-    }, [clauses, setClauses, clauseId]);
-    const addGroup = useCallback(() => {
-        const group = getDefaultGroup();
-        const condition = getDefaultCondition(schema[0].field);
-        setClauses(clauses
-            .set(group.id, group)
-            .set(condition.id, condition));
-        setTree(tree
-            .updateIn(childrenPath, (list) => list.set(group.id, { id: group.id, children: Immutable.Map({ [condition.id]: condition.id }) })));
-    }, [clauses, setClauses, tree, setTree, childrenPath, schema]);
-    const addCondition = useCallback(() => {
-        const condition = getDefaultCondition(schema[0].field);
-        setClauses(clauses.set(condition.id, condition));
-        setTree(tree
-            .updateIn(childrenPath, (list) => list.set(condition.id, condition.id)));
-    }, [clauses, setClauses, tree, setTree, childrenPath, schema]);
-    const handleConnective = useCallback((event, val) => {
-        if (val) {
-            setConnective(val);
-        }
-    }, [setConnective]);
-    return (jsxs(Grid, Object.assign({ item: !root, container: true, marginBottom: 1, paddingLeft: root ? 0 : 3, className: root ? "" : classes.group }, { children: [jsxs(Grid, Object.assign({ item: true, container: true, spacing: 1, justifyContent: multiple ? "space-between" : "end", alignItems: r({ xs: "flex-start", md: "center" }), marginBottom: 2, direction: r({ xs: "column-reverse", md: "row" }) }, { children: [multiple && (jsx(Grid, Object.assign({ item: true, xs: 12, md: "auto" }, { children: jsxs(ToggleButtonGroup, Object.assign({ value: group.connective, exclusive: true, onChange: handleConnective, color: "primary", "aria-label": `${getLocaleText("and", builderProps.localeText)}/${getLocaleText("or", builderProps.localeText)}`, size: "small" }, { children: [jsx(ToggleButton, Object.assign({ value: "and" }, { children: getLocaleText("and", builderProps.localeText) })), jsx(ToggleButton, Object.assign({ value: "or" }, { children: getLocaleText("or", builderProps.localeText) }))] })) }))), jsx(Grid, Object.assign({ item: true, xs: 12, md: "auto" }, { children: jsxs(ButtonGroup, Object.assign({ variant: "contained", size: "small", color: "secondary" }, { children: [jsx(Button, Object.assign({ startIcon: jsx(Add, {}), onClick: addCondition }, { children: getLocaleText("addCondition", builderProps.localeText) })), jsx(Button, Object.assign({ startIcon: jsx(Add, {}), onClick: addGroup }, { children: getLocaleText("addGroup", builderProps.localeText) }))] })) }))] })), jsx(Grid, Object.assign({ item: true, container: true, xs: true, direction: "column", rowSpacing: 2, columnSpacing: 1, paddingLeft: multiple ? 3 : 0 }, { children: treeGroup.children.toArray().map((c) => {
-                    if (typeof c[1] === "string") {
-                        return (jsx(Grid, Object.assign({ item: true, container: true, xs: true, className: multiple ? classes.child : "" }, { children: jsx(FilterCondition, { clauseId: c[0], path: childrenPath }) }), c[0]));
-                    }
-                    else {
-                        return (jsx(Grid, Object.assign({ item: true, container: true, xs: true, className: multiple ? classes.child : "" }, { children: jsx(FilterGroup, { clauseId: c[0], path: childrenPath }) }), c[0]));
-                    }
-                }) }))] })));
-};
-
-const defaultTranslators = {
-    "contains": ({ schema, field, value }) => {
-        if ((schema.type && schema.type !== "string") || typeof value !== "string") {
-            console.warn(`Warning: operation "contains" is only supported for fields of type "string"`);
-            return false;
-        }
-        if (schema.caseSensitive === true) {
-            return `contains(${field}, '${escapeODataString(value)}')`;
-        }
-        else {
-            return `contains(tolower(${field}), tolower('${escapeODataString(value)}'))`;
-        }
-    },
-    "null": ({ field }) => {
-        return `${field} eq null`;
-    },
-    "notnull": ({ field }) => {
-        return `${field} ne null`;
-    },
-    "default": ({ schema, field, op, value }) => {
-        if (schema.type === "date") {
-            return `date(${field}) ${op} ${value}`;
-        }
-        else if (schema.type === "datetime") {
-            return `${field} ${op} ${value}`;
-        }
-        else if (schema.type === "boolean") {
-            return `${field} ${op} ${value}`;
-        }
-        else if (!schema.type || schema.type === "string" || typeof value === "string") {
-            if (schema.caseSensitive === true) {
-                return `${field} ${op} '${escapeODataString(value)}'`;
-            }
-            else {
-                return `tolower(${field}) ${op} tolower('${escapeODataString(value)}')`;
-            }
-        }
-        else {
-            return `${field} ${op} ${value}`;
-        }
-    }
-};
-
-const UseODataFilter = () => {
-    const schema = useRecoilValue(schemaState);
-    const [clauses, tree] = useRecoilValue(waitForAll([clauseState, treeState]));
-    return useCallback(() => {
-        return buildGroup(schema, clauses, tree, rootGroupUuid, []);
-    }, [schema, clauses, tree]);
-};
-const UseODataFilterWithState = () => {
-    const schema = useRecoilValue(schemaState);
-    return useCallback((clauses, tree) => {
-        return buildGroup(schema, clauses, tree, rootGroupUuid, []);
-    }, [schema]);
-};
-const buildGroup = (schema, clauses, tree, id, path) => {
-    const clause = clauses.get(id);
-    const treeNode = tree.getIn([...path, id]);
-    if (!treeNode) {
-        console.error(`Tree node ${[...path, id].join("->")} not found`);
-        return false;
-    }
-    const childClauses = treeNode.children
-        .toArray()
-        .map((c) => {
-        if (typeof c[1] === "string") {
-            return buildCondition(schema, clauses, c[0]);
-        }
-        else {
-            return buildGroup(schema, clauses, tree, c[0], [...path, id, "children"]);
-        }
-    })
-        .filter(c => c !== false);
-    if (childClauses.length > 1) {
-        return {
-            filter: `(${childClauses.filter(c => c.filter).map(c => c.filter).join(` ${clause.connective} `)})`,
-            compute: `${childClauses.filter(c => c.compute).map(c => c.compute).join(",")}`,
-            select: childClauses.filter(c => c.select).flatMap(c => c.select),
-            serialised: { connective: clause.connective, children: childClauses.map(c => c.serialised) },
-            queryString: childClauses.reduce((x, c) => (Object.assign(Object.assign({}, x), c.queryString)), {})
-        };
-    }
-    else if (childClauses.length === 1) {
-        return {
-            filter: childClauses[0].filter,
-            compute: childClauses[0].compute,
-            select: childClauses[0].select,
-            serialised: { connective: clause.connective, children: [childClauses[0].serialised] },
-            queryString: childClauses[0].queryString
-        };
-    }
-    else {
-        console.error("Group has no children");
-        return false;
-    }
-};
-const buildCondition = (schema, clauses, id) => {
-    var _a;
-    const clause = clauses.get(id);
-    let condition = undefined;
-    if (!clause || clause.default === true) {
-        console.error(`Clause not found: ${id}`);
-        return false;
-    }
-    else {
-        condition = {
-            field: clause.field,
-            op: clause.op,
-            collectionOp: clause.collectionOp,
-            collectionField: clause.collectionField,
-            value: clause.value
-        };
-    }
-    const def = schema.find(d => d.field === clause.field);
-    if (!def) {
-        console.error(`Schema entry not found for field "${clause.field}"`);
-        return false;
-    }
-    const filterField = (_a = def.filterField) !== null && _a !== void 0 ? _a : def.field;
-    let innerResult;
-    if (clause.collectionOp) {
-        if (clause.collectionOp === "count") {
-            innerResult = {
-                filter: `${filterField}/$count ${clause.op} ${clause.value}`
-            };
-        }
-        else {
-            const collectionDef = def.collectionFields.find(d => d.field === clause.collectionField);
-            innerResult = buildInnerCondition(collectionDef, "x/" + clause.collectionField, clause.op, clause.value);
-        }
-    }
-    else {
-        innerResult = buildInnerCondition(def, filterField, clause.op, clause.value);
-    }
-    if (typeof innerResult !== "boolean") {
-        if (innerResult.filter) {
-            return {
-                filter: innerResult.filter,
-                compute: innerResult.compute,
-                select: innerResult.select,
-                serialised: condition
-            };
-        }
-        else {
-            return {
-                serialised: condition,
-                queryString: innerResult.queryString
-            };
-        }
-    }
-    else {
-        return false;
-    }
-};
-const buildInnerCondition = (schema, field, op, value) => {
-    if (schema.getCustomQueryString) {
-        return {
-            queryString: schema.getCustomQueryString(op, value)
-        };
-    }
-    if (schema.getCustomFilterString) {
-        const result = schema.getCustomFilterString(op, value);
-        if (typeof result === "string") {
-            return {
-                filter: result
-            };
-        }
-        else if (typeof result !== "boolean") {
-            const compute = result.compute;
-            if (typeof compute === "string") {
-                return {
-                    filter: result.filter,
-                    compute: compute
-                };
-            }
-            else {
-                return {
-                    filter: result.filter,
-                    compute: compute.compute,
-                    select: compute.select
-                };
-            }
-        }
-        else {
-            return result;
-        }
-    }
-    let translator;
-    if (op in defaultTranslators) {
-        translator = defaultTranslators[op];
-    }
-    else {
-        translator = defaultTranslators["default"];
-    }
-    const result = translator({ schema, field, op, value });
-    if (typeof result === "string") {
-        return {
-            filter: result
-        };
-    }
-    else {
-        return result;
-    }
-};
-
-const FilterRoot = ({ props }) => {
-    const setClauses = useSetRecoilState(clauseState);
-    const setProps = useSetRecoilState(propsState);
-    const setSchema = useSetRecoilState(schemaState);
-    const setTree = useSetRecoilState(treeState);
-    const odataFilter = UseODataFilter();
-    const odataFilterWithState = UseODataFilterWithState();
-    const [anchor, setAnchor] = useState(null);
-    const { onSubmit, onRestoreState, disableHistory, filter: propsFilter } = props;
-    const submit = useCallback((e) => {
-        e.preventDefault();
-        if (onSubmit) {
-            const result = odataFilter();
-            if (result.filter) {
-                const returned = onSubmit(Object.assign(Object.assign({}, result), { filter: result.filter }));
-                if (disableHistory !== true) {
-                    window.history.pushState(Object.assign(Object.assign(Object.assign({}, window.history.state), returned), { filterBuilder: {
-                            filter: result.filter,
-                            compute: result.compute,
-                            select: result.select,
-                            serialised: result.serialised,
-                            queryString: result.queryString
-                        } }), "");
-                }
-            }
-        }
-    }, [onSubmit, odataFilter, disableHistory]);
-    const reset = useCallback(() => {
-        setClauses(initialClauses.update(rootConditionUuid, (c) => (Object.assign(Object.assign({}, c), { field: props.schema[0].field }))));
-        setTree(initialTree);
-        if (onSubmit) {
-            onSubmit({ filter: "" });
-        }
-        if (disableHistory !== true) {
-            window.history.pushState(Object.assign(Object.assign({}, window.history.state), { filterBuilder: {
-                    reset: true
-                } }), "");
-        }
-    }, [setClauses, setTree, onSubmit, props.schema, disableHistory]);
-    const handleReset = useCallback(() => reset(), [reset]);
-    useEffect(() => {
-        setSchema(props.schema);
-    }, [props.schema, setSchema]);
-    const restoreDefault = useCallback(() => {
-        setClauses(initialClauses.update(rootConditionUuid, (c) => (Object.assign(Object.assign({}, c), { field: props.schema[0].field }))));
-        setTree(initialTree);
-    }, [props.schema, setClauses, setTree]);
-    const restoreState = useCallback((state, isPopstate) => {
-        let filter = "", serialised, queryString, compute, select;
-        if (state === null || state === void 0 ? void 0 : state.filterBuilder) {
-            if (state.filterBuilder.reset === true && isPopstate === true) {
-                restoreDefault();
-            }
-            compute = state.filterBuilder.compute;
-            filter = state.filterBuilder.filter;
-            select = state.filterBuilder.select;
-            serialised = state.filterBuilder.serialised;
-            queryString = state.filterBuilder.queryString;
-        }
-        else {
-            restoreDefault();
-        }
-        if (filter && serialised) {
-            const [tree, clauses] = deserialise(serialised);
-            setClauses(clauses);
-            setTree(tree);
-        }
-        if (onRestoreState) {
-            onRestoreState({ compute, filter, queryString, select, serialised }, state);
-        }
-    }, [onRestoreState, restoreDefault, setClauses, setTree]);
-    const restoreFilter = useCallback((serialised) => {
-        var _a;
-        const [tree, clauses] = deserialise(serialised);
-        setClauses(clauses);
-        setTree(tree);
-        if (onRestoreState) {
-            const result = odataFilterWithState(clauses, tree);
-            onRestoreState(Object.assign(Object.assign({}, result), { filter: (_a = result.filter) !== null && _a !== void 0 ? _a : "" }));
-        }
-    }, [setClauses, setTree, onRestoreState, odataFilterWithState]);
-    useEffect(() => {
-        if (disableHistory !== true) {
-            const handlePopState = (e) => { restoreState(e.state, true); };
-            window.addEventListener("popstate", handlePopState);
-            return () => window.removeEventListener("popstate", handlePopState);
-        }
-    }, [disableHistory, restoreState]);
-    useEffect(() => {
-        if (propsFilter) {
-            restoreFilter(propsFilter);
-        }
-        else {
-            restoreDefault();
-        }
-    }, [propsFilter, restoreFilter, restoreDefault]);
-    useMountEffect(() => {
-        setProps(props);
-        // restore query from history state if enabled
-        if (disableHistory !== true && window.history.state && window.history.state.filterBuilder) {
-            restoreState(window.history.state, false);
-        }
-        else if (propsFilter) {
-            restoreFilter(propsFilter);
-        }
-        else {
-            restoreDefault();
-        }
-    });
-    return (jsx(Fragment, { children: jsxs("form", Object.assign({ onSubmit: submit }, { children: [jsx(FilterGroup, { clauseId: rootGroupUuid, path: [], root: true }), jsxs(Grid, Object.assign({ container: true, spacing: 1 }, { children: [jsx(Grid, Object.assign({ item: true }, { children: jsxs(ButtonGroup, Object.assign({ variant: "contained", color: "primary" }, { children: [jsx(Button, Object.assign({ type: "submit" }, { children: "Search" })), props.searchMenuItems &&
-                                        jsx(Button, Object.assign({ size: "small", onClick: (e) => setAnchor(e.currentTarget), "aria-controls": anchor !== null ? "search-menu" : undefined, "aria-expanded": anchor !== null ? "true" : undefined, "aria-haspopup": "menu" }, { children: jsx(ArrowDropDown, {}) }))] })) })), jsx(Grid, Object.assign({ item: true }, { children: jsx(Button, Object.assign({ variant: "outlined", onClick: handleReset }, { children: "Reset" })) }))] })), props.searchMenuItems &&
-                    jsx(Popover, Object.assign({ anchorEl: anchor, open: anchor !== null, anchorOrigin: { vertical: "bottom", horizontal: "left" }, onClose: () => setAnchor(null), transitionDuration: 100 }, { children: jsx(Paper, { children: jsx(MenuList, Object.assign({ id: "search-menu" }, { children: props.searchMenuItems.map((item, i) => (jsx(MenuItem, Object.assign({ onClick: item.onClick }, { children: item.label }), `searchMenu_${i}`))) })) }) }))] })) }));
-};
-
-const FilterBuilder = (props) => {
-    return (jsx(RecoilRoot, Object.assign({ override: true }, { children: jsx(FilterRoot, { props: props }) })));
-};
-
-const defaultPageSize = 10;
-
-/**
- * Convert an Expand object (or array of objects) to a clause to use in an OData $expand query parameter
- * @param e Expand(s) to convert
- * @returns OData expand clause string
- */
-const ExpandToQuery = (expand) => {
-    if (expand === undefined) {
-        return "";
-    }
-    if (!Array.isArray(expand)) {
-        return ExpandToQuery([expand]);
-    }
-    // group all expands by the navigation field
-    const groupedExpands = GroupArrayBy(expand, (e) => e.navigationField);
-    // construct a single expand for each navigation field, combining nested query options (where possible)
-    const expands = [];
-    groupedExpands.forEach((e, k) => {
-        var _a, _b;
-        expands.push({
-            navigationField: k,
-            top: (_a = e.find(e2 => e2.top)) === null || _a === void 0 ? void 0 : _a.top,
-            orderBy: (_b = e.find(e2 => e2.orderBy)) === null || _b === void 0 ? void 0 : _b.orderBy,
-            count: e.some(e2 => e2.count),
-            select: Array.from(new Set(e.filter(e2 => e2.select).map(e2 => e2.select))).join(","),
-            expand: e.filter(e2 => e2.expand)
-                .map(e2 => e2.expand)
-                .reduce((a, b) => Array.isArray(b) ? a.concat(b) : [...a, b], [])
-        });
-    });
-    return expands.map(e => {
-        let result = `${e.navigationField}`;
-        const options = [
-            { type: "select", value: e.select },
-            { type: "expand", value: ExpandToQuery(e.expand) },
-            { type: "orderby", value: e.orderBy },
-            { type: "top", value: e.top },
-            { type: "count", value: e.count }
-        ];
-        if (options.some(o => o.value)) {
-            result += `(${options.filter(o => o.value).map(o => `$${o.type}=${o.value}`).join(";")})`;
-        }
-        return result;
-    }).join(",");
-};
-/**
- * Group an array into multiple arrays linked by a common key value
- * @param arr Array to group
- * @param keySelector Function to select property to group by
- * @returns ES6 Map of keys to arrays of values
- */
-const GroupArrayBy = (arr, keySelector) => arr
-    .reduce((m, e) => m.set(keySelector(e), [...m.get(keySelector(e)) || [], e]), new Map());
-/**
- * Flatten an object to a single level, i.e. { Person: { Name: "John" } } becomes { "Person.Name": "John" }.
- * Arrays are kept as arrays, with their elements flattened.
- * @param obj Object to flatten
- * @param sep Level separator (default ".")
- * @returns Flattened object
- */
-const Flatten = (obj, sep = ".") => _flatten(obj, sep, "");
-const _flatten = (obj, sep, prefix) => Object.keys(obj).reduce((x, k) => {
-    if (obj[k] !== null) {
-        const pre = prefix.length ? prefix + sep : "";
-        if (Array.isArray(obj[k])) {
-            x[pre + k] = obj[k].map(i => Flatten(i, sep));
-        }
-        else if (typeof obj[k] === "object") {
-            Object.assign(x, _flatten(obj[k], sep, pre + k));
-        }
-        else {
-            x[pre + k] = obj[k];
-        }
-    }
-    return x;
-}, {});
-const GetPageNumber = () => {
-    const params = new URLSearchParams(window.location.search);
-    if (params.has("page")) {
-        const pageVal = params.get("page");
-        if (pageVal) {
-            return parseInt(pageVal, 10) - 1;
-        }
-    }
-    return 0;
-};
-const GetPageSizeOrDefault = (defaultSize) => {
-    const params = new URLSearchParams(window.location.search);
-    if (params.has("page-size")) {
-        const sizeVal = params.get("page-size");
-        if (sizeVal) {
-            return parseInt(sizeVal, 10);
-        }
-    }
-    return defaultSize !== null && defaultSize !== void 0 ? defaultSize : defaultPageSize;
-};
-
-const ODataGridBase = (props) => {
-    var _a;
-    const [pageNumber, setPageNumber] = useState(GetPageNumber());
-    const [pageSize, setPageSize] = useState(GetPageSizeOrDefault(props.defaultPageSize));
-    const [rows, setRows] = useState([]);
-    const [rowCount, setRowCount] = useState(0);
-    const [loading, setLoading] = useState(true);
-    const [sortModel, setSortModel] = useState(props.defaultSortModel);
-    const [filter, setFilter] = useState("");
-    const [filterSelects, setFilterSelects] = useState();
-    const [compute, setCompute] = useState();
-    const [queryString, setQueryString] = useState();
-    const [visibleColumns, setVisibleColumns] = useState(props.columns
-        .filter(c => (props.columnVisibilityModel && props.columnVisibilityModel[c.field] !== false) || c.hide !== true)
-        .map(c => c.field));
-    const [columnVisibilityOverride, setColumnVisibilityOverride] = useState({});
-    const firstLoad = useRef(true);
-    const fetchCount = useRef(true);
-    const pendingFilter = useRef(false);
-    const r = useResponsive();
-    const fetchData = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
-        var _b;
-        if (!filter
-            && props.disableFilterBuilder !== true
-            && ((_b = props.filterBuilderProps) === null || _b === void 0 ? void 0 : _b.disableHistory) !== true
-            && window.history.state
-            && window.history.state.filterBuilder
-            && window.history.state.filterBuilder.reset !== true) {
-            // stop fetch if there is no filter but there is one in history which will be/has been restored
-            // this prevents a race condition between the initial data load and the query being restored
-            return;
-        }
-        setLoading(true);
-        // select all fields for visible columns
-        const fields = new Set(props.columns
-            .filter(c => visibleColumns.includes(c.field) && c.expand === undefined && c.filterOnly !== true && c.type !== "actions")
-            .map(c => { var _a; return (_a = c.select) !== null && _a !== void 0 ? _a : c.field; }));
-        if (props.alwaysSelect) {
-            props.alwaysSelect.forEach((c) => fields.add(c));
-        }
-        if (filterSelects) {
-            filterSelects.forEach((s) => fields.add(s));
-        }
-        const expands = props.columns
-            .filter(c => visibleColumns.includes(c.field) && c.expand)
-            .map(c => c.expand)
-            .reduce((a, b) => Array.isArray(b) ? a.concat(b) : [...a, b], []);
-        const query = new URLSearchParams();
-        if (fields.size > 0) {
-            query.append("$select", Array.from(fields).join(","));
-        }
-        if (expands.length > 0) {
-            query.append("$expand", ExpandToQuery(expands));
-        }
-        query.append("$top", pageSize.toString());
-        query.append("$skip", (pageNumber * pageSize).toString());
-        if (fetchCount.current) {
-            query.append("$count", "true");
-        }
-        if (queryString) {
-            for (const key in queryString) {
-                query.append(key, queryString[key]);
-            }
-        }
-        if (filter) {
-            query.append("$filter", filter);
-        }
-        else if (props.$filter) {
-            query.append("$filter", props.$filter);
-        }
-        if (compute) {
-            query.append("$compute", compute);
-        }
-        if (sortModel && sortModel.length > 0) {
-            const sortCols = sortModel
-                .map(s => ({ col: props.columns.find(c => c.field === s.field), sort: s.sort }))
-                .filter(c => c.col)
-                .map(c => { var _a; return `${(_a = c.col.sortField) !== null && _a !== void 0 ? _a : c.col.field}${c.sort === "desc" ? " desc" : ""}`; });
-            if (sortCols.length > 0) {
-                query.append("$orderby", sortCols.join(","));
-            }
-        }
-        const response = yield fetch(props.url + "?" + query.toString(), props.requestOptions);
-        if (response.ok) {
-            const data = yield response.json();
-            // flatten object so that the DataGrid can access all the properties
-            // i.e. { Person: { name: "John" } } becomes { "Person/name": "John" }
-            // keep the original object in the "result" property so that it can still be accessed via strong typing
-            const rows = data.value.map((v) => (Object.assign({ result: v }, Flatten(v, "/"))));
-            if (data["@odata.count"]) {
-                setRowCount(data["@odata.count"]);
-            }
-            setRows(rows);
-            setLoading(false);
-            firstLoad.current = false;
-            pendingFilter.current = false;
-            fetchCount.current = false;
-        }
-        else {
-            console.error(`API request failed: ${response.url}, HTTP ${response.status}`);
-        }
-    }), [
-        pageNumber,
-        pageSize,
-        visibleColumns,
-        sortModel,
-        filter,
-        filterSelects,
-        compute,
-        queryString,
-        props.url,
-        props.alwaysSelect,
-        props.columns,
-        props.$filter,
-        props.disableFilterBuilder,
-        (_a = props.filterBuilderProps) === null || _a === void 0 ? void 0 : _a.disableHistory,
-        props.requestOptions
-    ]);
-    const handleBuilderSubmit = useCallback((params) => {
-        var _a;
-        pendingFilter.current = true;
-        fetchCount.current = true;
-        if ((_a = props.filterBuilderProps) === null || _a === void 0 ? void 0 : _a.onSubmit) {
-            props.filterBuilderProps.onSubmit(params);
-        }
-        setCompute(params.compute);
-        setFilter(params.filter);
-        setFilterSelects(params.select);
-        setQueryString(params.queryString);
-        setPageNumber(0);
-        return { oDataGrid: { sortModel: sortModel } };
-    }, [props.filterBuilderProps, sortModel]);
-    const handleBuilderRestore = useCallback((params, state) => {
-        var _a, _b;
-        fetchCount.current = true;
-        if ((_a = props.filterBuilderProps) === null || _a === void 0 ? void 0 : _a.onRestoreState) {
-            props.filterBuilderProps.onRestoreState(params, state);
-        }
-        if (props.disableHistory !== true) {
-            if ((_b = state === null || state === void 0 ? void 0 : state.oDataGrid) === null || _b === void 0 ? void 0 : _b.sortModel) {
-                setSortModel(state.oDataGrid.sortModel);
-            }
-            else {
-                setSortModel(props.defaultSortModel);
-            }
-        }
-        setCompute(params.compute);
-        setFilter(params.filter);
-        setFilterSelects(params.select);
-        setQueryString(params.queryString);
-    }, [props.filterBuilderProps, props.disableHistory, props.defaultSortModel]);
-    useEffect(() => {
-        fetchData();
-    }, [fetchData]);
-    const { onColumnVisibilityModelChange, onSortModelChange } = props;
-    const handleSortModelChange = useCallback((model, details) => {
-        if (onSortModelChange) {
-            onSortModelChange(model, details);
-        }
-        setSortModel(model);
-        if (props.disableHistory !== true) {
-            window.history.pushState(Object.assign(Object.assign({}, window.history.state), { oDataGrid: { sortModel: model } }), "");
-        }
-    }, [onSortModelChange, props.disableHistory]);
-    useEffect(() => {
-        var _a, _b;
-        let changed = false;
-        const params = new URLSearchParams(window.location.search);
-        // update page query string parameter
-        const pageStr = params.get("page");
-        if (pageStr) {
-            const page = parseInt(pageStr, 10) - 1;
-            // update if already exists and is different to settings
-            if (page !== pageNumber) {
-                if (pageNumber !== 0) {
-                    params.set("page", (pageNumber + 1).toString());
-                }
-                else {
-                    // remove if first page
-                    params.delete("page");
-                }
-                changed = true;
-            }
-        }
-        else if (pageNumber !== 0) {
-            // add if doesn't already exist and not on first page
-            params.set("page", (pageNumber + 1).toString());
-            changed = true;
-        }
-        // update page-size query string parameter
-        const sizeStr = params.get("page-size");
-        if (sizeStr) {
-            const size = parseInt(sizeStr, 10);
-            if (size !== pageSize) {
-                if (pageSize !== ((_a = props.defaultPageSize) !== null && _a !== void 0 ? _a : defaultPageSize)) {
-                    params.set("page-size", pageSize.toString());
-                }
-                else {
-                    params.delete("page-size");
-                }
-                changed = true;
-            }
-        }
-        else if (pageSize !== ((_b = props.defaultPageSize) !== null && _b !== void 0 ? _b : defaultPageSize)) {
-            params.set("page-size", pageSize.toString());
-            changed = true;
-        }
-        // only run if modified and not the first load
-        if (changed && !firstLoad.current) {
-            const search = params.toString();
-            const url = search ? `${window.location.pathname}?${search}${window.location.hash}` : `${window.location.pathname}${window.location.hash}`;
-            // replace the state instead of pushing if a state has already been pushed by a filter
-            if (pendingFilter.current) {
-                window.history.replaceState(window.history.state, "", url);
-            }
-            else {
-                window.history.pushState(window.history.state, "", url);
-            }
-        }
-    }, [pageNumber, pageSize, props.defaultPageSize]);
-    useEffect(() => {
-        const handlePopState = (e) => {
-            var _a, _b, _c, _d;
-            const params = new URLSearchParams(window.location.search);
-            const pageVal = params.get("page");
-            if (pageVal) {
-                const page = parseInt(pageVal, 10) - 1;
-                setPageNumber(page);
-            }
-            else if (pageNumber !== 0) {
-                // reset to first page if not provided and not already on first page
-                setPageNumber(0);
-            }
-            const sizeVal = params.get("page-size");
-            if (sizeVal) {
-                const size = parseInt(sizeVal, 10) - 1;
-                setPageSize(size);
-            }
-            else if ((_a = pageSize !== props.defaultPageSize) !== null && _a !== void 0 ? _a : defaultPageSize) {
-                // reset to default if not provided and not already default
-                setPageSize((_b = props.defaultPageSize) !== null && _b !== void 0 ? _b : defaultPageSize);
-            }
-            if (props.disableHistory !== true && props.disableFilterBuilder === true) {
-                // only restore sort model from history if history is enabled and FilterBuilder is disabled
-                // if FilterBuilder is enabled sort model restoration is handled in handleBuilderRestore
-                if ((_d = (_c = e.state) === null || _c === void 0 ? void 0 : _c.oDataGrid) === null || _d === void 0 ? void 0 : _d.sortModel) {
-                    setSortModel(e.state.oDataGrid.sortModel);
-                }
-                else {
-                    setSortModel(props.defaultSortModel);
-                }
-            }
-        };
-        window.addEventListener("popstate", handlePopState);
-        return () => window.removeEventListener("popstate", handlePopState);
-    }, [pageNumber, pageSize, props.defaultPageSize, props.defaultSortModel, props.disableHistory, props.disableFilterBuilder]);
-    const handlePageChange = useCallback((page) => {
-        setPageNumber(page);
-    }, []);
-    const handlePageSizeChange = useCallback((size) => {
-        setPageSize(size);
-    }, []);
-    const visibility = useMemo(() => {
-        const v = {};
-        if (props.columnVisibilityModel) {
-            for (const field in props.columnVisibilityModel) {
-                if (field in columnVisibilityOverride) {
-                    v[field] = columnVisibilityOverride[field];
-                }
-                else if (typeof props.columnVisibilityModel[field] === "boolean") {
-                    v[field] = props.columnVisibilityModel[field];
-                }
-                else {
-                    v[field] = r(props.columnVisibilityModel[field]);
-                }
-            }
-        }
-        else {
-            props.columns.filter(c => c.filterOnly !== true).forEach(c => {
-                if (c.field in columnVisibilityOverride) {
-                    v[c.field] = columnVisibilityOverride[c.field];
-                }
-                else if (typeof c.hide === "boolean") {
-                    v[c.field] = !c.hide;
-                }
-                else if (c.hide) {
-                    v[c.field] = !r(c.hide);
-                }
-            });
-        }
-        props.columns.filter(c => c.filterOnly === true).forEach(c => {
-            v[c.field] = false;
-        });
-        return v;
-    }, [props.columnVisibilityModel, r, props.columns, columnVisibilityOverride]);
-    const handleColumnVisibilityModelChange = useCallback((model, details) => {
-        if (onColumnVisibilityModelChange) {
-            onColumnVisibilityModelChange(model, details);
-        }
-        // find the field which has been changed
-        const column = Object.keys(model).find((key) => visibility[key] !== model[key]);
-        if (column) {
-            const visible = model[column];
-            setColumnVisibilityOverride((v) => (Object.assign(Object.assign({}, v), { [column]: visible })));
-            if (visible) {
-                setVisibleColumns((v) => [...v, column]);
-            }
-            else {
-                setVisibleColumns((v) => v.filter(c => c !== column));
-            }
-        }
-    }, [onColumnVisibilityModelChange, visibility]);
-    const gridColumns = useMemo(() => props.columns.filter(c => c.filterOnly !== true), [props.columns]);
-    const GridComponent = props.component;
-    return (jsxs(Fragment, { children: [props.$filter === undefined && props.disableFilterBuilder !== true &&
-                jsx(Box, Object.assign({ mb: 2 }, { children: jsx(FilterBuilder, Object.assign({}, props.filterBuilderProps, { schema: props.columns, onSubmit: handleBuilderSubmit, onRestoreState: handleBuilderRestore })) })), jsx(GridComponent, Object.assign({ autoHeight: true, ref: React.createRef() }, props, { columns: gridColumns, rows: rows, rowCount: rowCount, pagination: true, paginationMode: "server", page: pageNumber, pageSize: pageSize, onPageChange: handlePageChange, onPageSizeChange: handlePageSizeChange, disableColumnFilter: true, loading: loading, columnVisibilityModel: visibility, onColumnVisibilityModelChange: handleColumnVisibilityModelChange, sortingMode: "server", sortModel: sortModel, onSortModelChange: handleSortModelChange }))] }));
-};
-
-const ODataGrid = (props) => (jsx(ODataGridBase, Object.assign({}, props, { component: DataGrid })));
-
-export { FilterBuilder, ODataGrid, allOperators, defaultTranslators, escapeODataString, numericOperators };
+import{jsxs as e,jsx as t}from"react/jsx-runtime";import l,{useEffect as i,useState as o,useMemo as a,Fragment as n,useCallback as r,useRef as s}from"react";import{Box as d}from"@mui/system";import{useTheme as u}from"@mui/material/styles";import{atom as c,useRecoilValue as p,useRecoilState as g,useSetRecoilState as f,waitForAll as m,RecoilRoot as h}from"recoil";import{Remove as $,Add as v,ArrowDropDown as y}from"@mui/icons-material";import{Grid as b,Autocomplete as S,TextField as x,FormControl as C,InputLabel as T,Select as F,MenuItem as O,IconButton as _,useTheme as P,ToggleButtonGroup as M,ToggleButton as B,ButtonGroup as G,Button as L,Popover as k,Paper as I,MenuList as D}from"@mui/material";import z from"immutable";import{LocalizationProvider as q,DatePicker as w,DateTimePicker as E}from"@mui/x-date-pickers";import{v4 as A}from"uuid";import{createMakeStyles as N}from"tss-react";import{DataGrid as U}from"@mui/x-data-grid";import j from"classnames";function __awaiter(e,t,l,i){return new(l||(l=Promise))(function(o,a){function n(e){try{s(i.next(e))}catch(t){a(t)}}function r(e){try{s(i.throw(e))}catch(t){a(t)}}function s(e){var t;e.done?o(e.value):((t=e.value)instanceof l?t:new l(function(e){e(t)})).then(n,r)}s((i=i.apply(e,t||[])).next())})}let useResponsive=()=>{let e=u(),t=useBreakpoints();return function(l){let i;return e.breakpoints.keys.forEach(e=>{t[e]&&null!=l[e]&&(i=e)}),i&&l[i]}},useMountEffect=e=>i(e,[]),useBreakpoints=()=>{let e=u(),[t,l]=o(getMatches(e.breakpoints.keys,e));return i(()=>{let t=getQueries(e.breakpoints.keys,e),i={},o=e=>{l(l=>{var i,o;return Object.assign(Object.assign({},l),{[e]:null!==(o=null===(i=t[e])||void 0===i?void 0:i.matches)&&void 0!==o&&o})})};return e.breakpoints.keys.forEach(e=>{i[e]=()=>o(e),t[e].addEventListener("change",i[e])}),()=>{e.breakpoints.keys.forEach(e=>{t[e].removeEventListener("change",i[e])})}},[e]),t},getQueries=(e,t)=>e.reduce((e,l)=>Object.assign(Object.assign({},e),{[l]:window.matchMedia(t.breakpoints.up(l).replace(/^@media( ?)/m,""))}),{}),getMatches=(e,t)=>e.reduce((e,l)=>Object.assign(Object.assign({},e),{[l]:window.matchMedia(t.breakpoints.up(l).replace(/^@media( ?)/m,"")).matches}),{}),rootGroupUuid="17c63a07-397b-4f03-a74b-2f935dcc6c8a",rootConditionUuid="18c1713a-2480-40c0-b60f-220a3fd4b117",allOperators=["eq","ne","gt","lt","ge","le","contains","null","notnull"],numericOperators=["eq","ne","gt","lt","ge","le"],initialClauses=z.Map({[rootGroupUuid]:{id:rootGroupUuid,connective:"and"},[rootConditionUuid]:{id:rootConditionUuid,field:"",op:"eq",value:null,default:!0}}),initialTree=z.Map({[rootGroupUuid]:{id:rootGroupUuid,children:z.Map({[rootConditionUuid]:rootConditionUuid})}}),defaultLocale={and:"And",or:"Or",addCondition:"Add Condition",addGroup:"Add Group",field:"Field",operation:"Operation",value:"Value",collectionOperation:"Operation",collectionField:"Field",search:"Search",reset:"Reset",opAny:"Has at least one",opAll:"All have",opCount:"Count",opEq:"=",opNe:"≠",opGt:">",opLt:"<",opGe:"≥",opLe:"≤",opContains:"Contains",opNull:"Is Blank",opNotNull:"Is Not Blank"},schemaState=c({key:"schema",default:[]}),clauseState=c({key:"filterClauses",default:initialClauses}),treeState=c({key:"filterTree",default:initialTree}),propsState=c({key:"props",default:{}}),getDefaultCondition=e=>({field:e,op:"eq",value:null,id:A()}),getDefaultGroup=()=>({connective:"and",id:A()}),getSelectOption=e=>"string"==typeof e?{value:e,label:e}:"number"==typeof e?{value:e.toString(),label:e.toString()}:e,getLocaleText=(e,t)=>void 0!==t&&t[e]?t[e]:defaultLocale[e],deserialise=e=>{let[t,l]=groupObjToMap(e,rootGroupUuid);return[z.Map({[rootGroupUuid]:t}),l]},groupObjToMap=(e,t,l)=>{let i=z.Map();return l||(l=z.Map()),l=l.set(t,Object.assign({id:t},e)),e.children.forEach(e=>{let t=A();l=l.set(t,Object.assign({id:t},e));let o=e;if(o.connective){let a=groupObjToMap(o,t,l);i=i.set(t,a[0]),l=l.merge(a[1])}else i=i.set(t,t)}),[{id:t,children:i},l]},escapeODataString=e=>e.replace("'","''"),FilterInputs=({clauseId:l,field:i,onFieldChange:o,op:r,onOpChange:s,value:d,onValueChange:u,collectionOp:c,onCollectionOpChange:g,collectionField:f,onCollectionFieldChange:m})=>{var h,$,v,y,_,P,M,B,G,L,k,I,D,z;let A=p(schemaState),N=p(propsState),U=a(()=>{var e;return null===(e=N.localizationProviderProps)||void 0===e?void 0:e.dateAdapter},[N]),j=a(()=>{var e,t,l,o,a,n,r;if(!i&&A.length<1)return null;let s;if(!(s=i&&null!==(e=A.find(e=>e.field===i))&&void 0!==e?e:A[0]))return null;let d=i,u,p=null!==(t=s.filterType)&&void 0!==t?t:s.type,g=s.valueOptions,m=null!==(l=s.filterOperators)&&void 0!==l?l:allOperators;!0===s.collection&&s.collectionFields&&(d=(u=f&&null!==(o=s.collectionFields.find(e=>e.field===f))&&void 0!==o?o:s.collectionFields[0]).field,p=u.type,g=u.valueOptions,"count"!==c?m=null!==(a=u.filterOperators)&&void 0!==a?a:allOperators:(m=numericOperators,p="number"));let h;return"singleSelect"===p&&"function"==typeof g?h=g({field:d}).map(e=>getSelectOption(e)):"singleSelect"===p&&g&&(h=g.map(e=>getSelectOption(e))),Object.assign(Object.assign({},s),{fieldLabel:null!==(r=null!==(n=s.label)&&void 0!==n?n:s.headerName)&&void 0!==r?r:s.field,type:p,ops:m,valueOptions:h,colField:u})},[i,f,c,A]),V=a(()=>A.filter(e=>!1!==e.filterable).map(e=>{var t,l,i;return{label:null!==(l=null!==(t=e.label)&&void 0!==t?t:e.headerName)&&void 0!==l?l:e.field,field:e.field,group:null!==(i=e.autocompleteGroup)&&void 0!==i?i:""}}).sort((e,t)=>N.autocompleteGroups?N.autocompleteGroups.indexOf(e.group)-N.autocompleteGroups.indexOf(t.group):e.group.localeCompare(t.group)),[A,N]);return A.length<1||!j?null:e(n,{children:[t(b,Object.assign({item:!0,xs:12,md:!!j.collection||4},{children:t(S,Object.assign({size:"small"},N.autocompleteProps,{options:V,renderInput:e=>t(x,Object.assign({label:getLocaleText("field",N.localeText)},N.textFieldProps,e)),value:{label:j.fieldLabel,field:j.field,group:j.autocompleteGroup},onChange:(e,t)=>o(j.field,r,t.field),disableClearable:!0,isOptionEqualToValue:(e,t)=>e.field===t.field,groupBy:e=>e.group}))})),!0===j.collection&&t(b,Object.assign({item:!0,xs:12,md:!0},{children:e(C,Object.assign({fullWidth:!0,size:"small"},{children:[t(T,Object.assign({id:`${l}_label-collection-op`},{children:getLocaleText("collectionOperation",N.localeText)})),e(F,Object.assign({label:getLocaleText("collectionOperation",N.localeText)},N.selectProps,{value:c,onChange:e=>g(e.target.value),labelId:`${l}_label-collection-op`},{children:[t(O,Object.assign({value:"any"},{children:getLocaleText("opAny",N.localeText)})),t(O,Object.assign({value:"all"},{children:getLocaleText("opAll",N.localeText)})),t(O,Object.assign({value:"count"},{children:getLocaleText("opCount",N.localeText)})),]})),]}))})),!0===j.collection&&"count"!==c&&t(b,Object.assign({item:!0,xs:12,md:!0},{children:t(S,Object.assign({size:"small"},N.autocompleteProps,{options:null!==($=null===(h=j.collectionFields)||void 0===h?void 0:h.map(e=>({label:e.label,field:e.field})))&&void 0!==$?$:[],renderInput:e=>t(x,Object.assign({label:getLocaleText("collectionField",N.localeText)},N.textFieldProps,e)),value:{label:null===(v=j.colField)||void 0===v?void 0:v.label,field:f},onChange:(e,t)=>m(i,f,r,t.field),disableClearable:!0,isOptionEqualToValue:(e,t)=>e.field===t.field}))})),j.renderCustomFilter?j.renderCustomFilter(d,u):t(b,Object.assign({item:!0,xs:12,md:!0},{children:e(C,Object.assign({fullWidth:!0,size:"small"},{children:[t(T,Object.assign({id:`${l}_label-op`},{children:"Operation"})),e(F,Object.assign({},N.selectProps,{value:r,onChange:e=>s(e.target.value),labelId:`${l}_label-op`,label:"Operation"},{children:[j.ops.includes("eq")&&t(O,Object.assign({value:"eq"},{children:getLocaleText("opEq",N.localeText)})),j.ops.includes("ne")&&t(O,Object.assign({value:"ne"},{children:getLocaleText("opNe",N.localeText)})),j.ops.includes("gt")&&t(O,Object.assign({value:"gt"},{children:getLocaleText("opGt",N.localeText)})),j.ops.includes("lt")&&t(O,Object.assign({value:"lt"},{children:getLocaleText("opLt",N.localeText)})),j.ops.includes("ge")&&t(O,Object.assign({value:"ge"},{children:getLocaleText("opGe",N.localeText)})),j.ops.includes("le")&&t(O,Object.assign({value:"le"},{children:getLocaleText("opLe",N.localeText)})),j.ops.includes("contains")&&t(O,Object.assign({value:"contains"},{children:getLocaleText("opContains",N.localeText)})),j.ops.includes("null")&&t(O,Object.assign({value:"null"},{children:getLocaleText("opNull",N.localeText)})),j.ops.includes("notnull")&&t(O,Object.assign({value:"notnull"},{children:getLocaleText("opNotNull",N.localeText)})),]})),]}))})),!j.renderCustomFilter&&t(b,Object.assign({item:!0,xs:!0},{children:"null"!==r&&"notnull"!==r&&(j.renderCustomInput?j.renderCustomInput(d,u):e(n,{children:["date"===j.type&&t(q,Object.assign({dateAdapter:U},N.localizationProviderProps,{children:t(w,Object.assign({label:getLocaleText("value",N.localeText)},N.datePickerProps,j.datePickerProps,{value:null!=d?d:"",renderInput:e=>t(x,Object.assign({required:!0,fullWidth:!0,size:"small"},N.textFieldProps,j.textFieldProps,e)),onChange:e=>u(new U().formatByString(e,"YYYY-MM-DD"))}))})),"datetime"===j.type&&t(q,Object.assign({dateAdapter:U},N.localizationProviderProps,{children:t(E,Object.assign({label:getLocaleText("value",N.localeText)},j.dateTimePickerProps,{value:null!=d?d:"",renderInput:e=>t(x,Object.assign({required:!0,fullWidth:!0,size:"small"},N.textFieldProps,j.textFieldProps,e)),onChange:e=>u(new U().toISO(e))}))})),"boolean"===j.type&&e(C,Object.assign({fullWidth:!0,size:"small"},null===(y=j.selectProps)||void 0===y?void 0:y.formControlProps,{children:[t(T,Object.assign({id:`${l}_label-bool-value`},{children:null!==(P=null===(_=j.selectProps)||void 0===_?void 0:_.label)&&void 0!==P?P:getLocaleText("value",N.localeText)})),e(F,Object.assign({label:null!==(B=null===(M=j.selectProps)||void 0===M?void 0:M.label)&&void 0!==B?B:getLocaleText("value",N.localeText)},N.selectProps,null===(G=j.selectProps)||void 0===G?void 0:G.selectProps,{value:null==d||d,onChange:e=>u(e.target.value),labelId:`${l}_label-bool-value`},{children:[t(O,Object.assign({value:"true"},{children:"Yes"})),t(O,Object.assign({value:"false"},{children:"No"})),j.nullable&&t(O,Object.assign({value:"null"},{children:"Unknown"})),]})),]})),"singleSelect"===j.type&&j.valueOptions&&e(C,Object.assign({fullWidth:!0,size:"small"},null===(L=j.selectProps)||void 0===L?void 0:L.formControlProps,{children:[t(T,Object.assign({id:`${l}_label-select-value`},{children:null!==(I=null===(k=j.selectProps)||void 0===k?void 0:k.label)&&void 0!==I?I:getLocaleText("value",N.localeText)})),t(F,Object.assign({label:null!==(z=null===(D=j.selectProps)||void 0===D?void 0:D.label)&&void 0!==z?z:getLocaleText("value",N.localeText),value:null!=d?d:"",onChange:e=>u(e.target.value),labelId:`${l}_label-select-value`},{children:j.valueOptions.map((e,o)=>t(O,Object.assign({value:e.value},{children:e.label}),`${l}_${i}_select_${o}`))})),]})),(!j.type||"string"===j.type||"number"===j.type)&&t(x,Object.assign({required:!0,size:"small",fullWidth:!0,label:getLocaleText("value",N.localeText)},N.textFieldProps,j.textFieldProps,{value:null!=d?d:"",onChange:e=>u("number"===j.type?parseFloat(e.target.value):e.target.value),type:"number"===j.type?"number":"text"})),]}))})),]})};var FilterInputs$1=l.memo(FilterInputs);let FilterCondition=({clauseId:l,path:i})=>{let[o,n]=g(clauseState),s=f(treeState),d=p(schemaState),u=a(()=>o.get(l),[o,l]),c=r((e,t,i)=>{let o=d.find(t=>t.field===e),a=d.find(e=>e.field===i);n(e=>e.update(l,e=>{var l;let n=Object.assign({},e);return n.field=i,n.default=!1,o&&a&&(o.type!==a.type&&(n.value=""),a.filterOperators&&!a.filterOperators.includes(t)&&(n.op=null!==(l=a.filterOperators[0])&&void 0!==l?l:"eq"),!0===a.collection&&a.collectionFields?(n.collectionField=a.collectionFields[0].field,n.collectionOp="any",a.collectionFields[0].filterOperators?n.op=a.collectionFields[0].filterOperators[0]:n.op="eq"):(n.collectionField=void 0,n.collectionOp=void 0)),n}))},[d,n,l]),m=r(e=>{n(t=>t.update(l,t=>Object.assign(Object.assign({},t),{op:e,default:!1})))},[n,l]),h=r(e=>{n(t=>t.update(l,t=>Object.assign(Object.assign({},t),{value:e,default:!1})))},[n,l]),v=r(e=>{n(t=>t.update(l,t=>{let l=Object.assign(Object.assign({},t),{collectionOp:e,default:!1});return"count"!==e||numericOperators.includes(l.op)||(l.op="eq"),l}))},[n,l]),y=r((e,t,i,o)=>{let a=d.find(t=>t.field===e);n(e=>e.update(l,e=>{var l;let n=Object.assign({},e);if(n.collectionField=o,n.default=!1,a&&a.collectionFields&&t&&o){let r=a.collectionFields.find(e=>e.field===t),s=a.collectionFields.find(e=>e.field===o);r.type!==s.type&&(n.value=""),s.filterOperators&&!s.filterOperators.includes(i)&&(n.op=null!==(l=s.filterOperators[0])&&void 0!==l?l:"eq")}return n}))},[d,n,l]),S=r(()=>{i.length>2?s(e=>e.withMutations(e=>{e.deleteIn([...i,l]);let t=[...i];t.splice(-1,1);do{let o=e.getIn(t);if(o&&1>o.children.count())e.deleteIn(t);else{e.deleteIn([...i,l]);break}t.splice(-2,2)}while(t.length>2)})):s(e=>e.deleteIn([...i,l])),n(e=>e.remove(l))},[n,s,l,i]);return u?e(b,Object.assign({container:!0,spacing:1},{children:[t(FilterInputs$1,{clauseId:l,field:u.field,onFieldChange:c,op:u.op,onOpChange:m,value:u.value,onValueChange:h,collectionOp:u.collectionOp,onCollectionOpChange:v,collectionField:u.collectionField,onCollectionFieldChange:y}),t(b,Object.assign({item:!0,xs:"auto"},{children:t(_,Object.assign({onClick:S},{children:t($,{})}))}))]})):null},{makeStyles:R}=N({useTheme:P}),useStyles=R()(e=>({group:{borderWidth:1,borderColor:"dark"===e.palette.mode?"rgb(81,81,81)":"rgb(224,224,224)",borderRadius:e.shape.borderRadius,borderStyle:"solid",padding:e.spacing(2)},child:{position:"relative","&:not(:last-of-type)::before":{content:"''",display:"block",position:"absolute",width:2,height:"100%",background:e.palette.primary.main,left:e.spacing(-1)},"&:first-of-type::before":{height:`calc(100% + ${e.spacing(2)})`,top:0},"&::after":{content:"''",display:"block",position:"absolute",left:e.spacing(-1),top:`calc(${e.spacing(1)} + 1px)`,width:e.spacing(2),height:"50%",borderWidth:2,borderStyle:"solid",borderColor:e.palette.primary.main,borderRight:"none",borderTop:"none",borderBottomLeftRadius:e.shape.borderRadius}}})),FilterGroup=({clauseId:l,path:i,root:o})=>{let{classes:n}=useStyles(),s=useResponsive(),[d,u]=p(m([treeState,clauseState])),c=f(treeState),g=f(clauseState),h=p(schemaState),$=p(propsState),y=a(()=>u.get(l),[u,l]),S=a(()=>d.getIn([...i,l]),[d,i,l]),x=a(()=>[...i,l,"children"],[i,l]),C=a(()=>S.children.count()>1,[S]),T=r(e=>{g(u.update(l,t=>Object.assign(Object.assign({},t),{connective:e})))},[u,g,l]),F=r(()=>{let e=getDefaultGroup(),t=getDefaultCondition(h[0].field);g(u.set(e.id,e).set(t.id,t)),c(d.updateIn(x,l=>l.set(e.id,{id:e.id,children:z.Map({[t.id]:t.id})})))},[u,g,d,c,x,h]),O=r(()=>{let e=getDefaultCondition(h[0].field);g(u.set(e.id,e)),c(d.updateIn(x,t=>t.set(e.id,e.id)))},[u,g,d,c,x,h]),_=r((e,t)=>{t&&T(t)},[T]);return e(b,Object.assign({item:!o,container:!0,marginBottom:1,paddingLeft:o?0:3,className:o?"":n.group},{children:[e(b,Object.assign({item:!0,container:!0,spacing:1,justifyContent:C?"space-between":"end",alignItems:s({xs:"flex-start",md:"center"}),marginBottom:2,direction:s({xs:"column-reverse",md:"row"})},{children:[C&&t(b,Object.assign({item:!0,xs:12,md:"auto"},{children:e(M,Object.assign({value:y.connective,exclusive:!0,onChange:_,color:"primary","aria-label":`${getLocaleText("and",$.localeText)}/${getLocaleText("or",$.localeText)}`,size:"small"},{children:[t(B,Object.assign({value:"and"},{children:getLocaleText("and",$.localeText)})),t(B,Object.assign({value:"or"},{children:getLocaleText("or",$.localeText)}))]}))})),t(b,Object.assign({item:!0,xs:12,md:"auto"},{children:e(G,Object.assign({variant:"contained",size:"small",color:"secondary",className:"action-buttons",id:"filter-add-action-btn"},{children:[t(L,Object.assign({startIcon:t(v,{}),onClick:O,className:"secondary-btn"},{children:getLocaleText("addCondition",$.localeText)})),t(L,Object.assign({startIcon:t(v,{}),onClick:F,className:"secondary-btn"},{children:getLocaleText("addGroup",$.localeText)}))]}))}))]})),t(b,Object.assign({item:!0,container:!0,xs:!0,direction:"column",rowSpacing:2,columnSpacing:1,paddingLeft:C?3:0},{children:S.children.toArray().map(e=>"string"==typeof e[1]?t(b,Object.assign({item:!0,container:!0,xs:!0,className:C?n.child:""},{children:t(FilterCondition,{clauseId:e[0],path:x})}),e[0]):t(b,Object.assign({item:!0,container:!0,xs:!0,className:C?n.child:""},{children:t(FilterGroup,{clauseId:e[0],path:x})}),e[0]))}))]}))},defaultTranslators={contains:({schema:e,field:t,value:l})=>e.type&&"string"!==e.type||"string"!=typeof l?(console.warn('Warning: operation "contains" is only supported for fields of type "string"'),!1):!0===e.caseSensitive?`contains(${t}, '${escapeODataString(l)}')`:`contains(tolower(${t}), tolower('${escapeODataString(l)}'))`,null:({schema:e,field:t})=>"string"===e.type?`(${t} eq null or ${t} eq '')`:`${t} eq null`,notnull:({schema:e,field:t})=>"string"===e.type?`(${t} ne null or ${t} ne '')`:`${t} ne null`,default:({schema:e,field:t,op:l,value:i})=>"date"===e.type?`date(${t}) ${l} '${i}'`:"datetime"===e.type?`${t} ${l} '${i}'`:"boolean"===e.type?`${t} ${l} ${i}`:e.type&&"string"!==e.type&&"string"!=typeof i?`${t} ${l} ${i}`:!0===e.caseSensitive?`${t} ${l} '${escapeODataString(i)}'`:`tolower(${t}) ${l} tolower('${escapeODataString(i)}')`},UseODataFilter=()=>{let e=p(schemaState),[t,l]=p(m([clauseState,treeState]));return r(()=>buildGroup(e,t,l,rootGroupUuid,[]),[e,t,l])},UseODataFilterWithState=()=>{let e=p(schemaState);return r((t,l)=>buildGroup(e,t,l,rootGroupUuid,[]),[e])},buildGroup=(e,t,l,i,o)=>{let a=t.get(i),n=l.getIn([...o,i]);if(!n)return console.error(`Tree node ${[...o,i].join("->")} not found`),!1;let r=n.children.toArray().map(a=>"string"==typeof a[1]?buildCondition(e,t,a[0]):buildGroup(e,t,l,a[0],[...o,i,"children"])).filter(e=>!1!==e);return r.length>1?{filter:`(${r.filter(e=>e.filter).map(e=>e.filter).join(` ${a.connective} `)})`,compute:`${r.filter(e=>e.compute).map(e=>e.compute).join(",")}`,select:r.filter(e=>e.select).flatMap(e=>e.select),serialised:{connective:a.connective,children:r.map(e=>e.serialised)},queryString:r.reduce((e,t)=>Object.assign(Object.assign({},e),t.queryString),{})}:1===r.length?{filter:r[0].filter,compute:r[0].compute,select:r[0].select,serialised:{connective:a.connective,children:[r[0].serialised]},queryString:r[0].queryString}:(console.error("Group has no children"),!1)},buildCondition=(e,t,l)=>{var i;let o=t.get(l),a;if(!o||!0===o.default)return console.error(`Clause not found: ${l}`),!1;a={field:o.field,op:o.op,collectionOp:o.collectionOp,collectionField:o.collectionField,value:o.value};let n=e.find(e=>e.field===o.field);if(!n)return console.error(`Schema entry not found for field "${o.field}"`),!1;let r=null!==(i=n.filterField)&&void 0!==i?i:n.field,s;return"boolean"!=typeof(s=o.collectionOp?"count"===o.collectionOp?{filter:`${r}/$count ${o.op} ${o.value}`}:buildInnerCondition(n.collectionFields.find(e=>e.field===o.collectionField),"x/"+o.collectionField,o.op,o.value):buildInnerCondition(n,r,o.op,o.value))&&(s.filter?{filter:s.filter,compute:s.compute,select:s.select,serialised:a}:{serialised:a,queryString:s.queryString})},buildInnerCondition=(e,t,l,i)=>{if(e.getCustomQueryString)return{queryString:e.getCustomQueryString(l,i)};if(e.getCustomFilterString){let o=e.getCustomFilterString(l,i);if("string"==typeof o)return{filter:o};if("boolean"==typeof o)return o;{let a=o.compute;return"string"==typeof a?{filter:o.filter,compute:a}:{filter:o.filter,compute:a.compute,select:a.select}}}let n,r=(n=l in defaultTranslators?defaultTranslators[l]:defaultTranslators.default)({schema:e,field:t,op:l,value:i});return"string"==typeof r?{filter:r}:r},FilterRoot=({props:l})=>{let a=f(clauseState),s=f(propsState),d=f(schemaState),u=f(treeState),c=UseODataFilter(),p=UseODataFilterWithState(),[g,m]=o(null),{onSubmit:h,onRestoreState:$,disableHistory:v,filter:S}=l,x=r(e=>{if(e.preventDefault(),h){let t=c();if(t.filter){let l=h(Object.assign(Object.assign({},t),{filter:t.filter}));!0!==v&&window.history.pushState(Object.assign(Object.assign(Object.assign({},window.history.state),l),{filterBuilder:{filter:t.filter,compute:t.compute,select:t.select,serialised:t.serialised,queryString:t.queryString}}),"")}}},[h,c,v]),C=r(()=>{a(initialClauses.update(rootConditionUuid,e=>Object.assign(Object.assign({},e),{field:l.schema[0].field}))),u(initialTree),h&&h({filter:""}),!0!==v&&window.history.pushState(Object.assign(Object.assign({},window.history.state),{filterBuilder:{reset:!0}}),"")},[a,u,h,l.schema,v]),T=r(()=>C(),[C]);i(()=>{d(l.schema)},[l.schema,d]);let F=r(()=>{a(initialClauses.update(rootConditionUuid,e=>Object.assign(Object.assign({},e),{field:l.schema[0].field}))),u(initialTree)},[l.schema,a,u]),_=r((e,t)=>{let l="",i,o,n,r;if((null==e?void 0:e.filterBuilder)?(!0===e.filterBuilder.reset&&!0===t&&F(),n=e.filterBuilder.compute,l=e.filterBuilder.filter,r=e.filterBuilder.select,i=e.filterBuilder.serialised,o=e.filterBuilder.queryString):F(),l&&i){let[s,d]=deserialise(i);a(d),u(s)}$&&$({compute:n,filter:l,queryString:o,select:r,serialised:i},e)},[$,F,a,u]),P=r(e=>{var t;let[l,i]=deserialise(e);if(a(i),u(l),$){let o=p(i,l);$(Object.assign(Object.assign({},o),{filter:null!==(t=o.filter)&&void 0!==t?t:""}))}},[a,u,$,p]);return i(()=>{if(!0!==v){let e=e=>{_(e.state,!0)};return window.addEventListener("popstate",e),()=>window.removeEventListener("popstate",e)}},[v,_]),i(()=>{S?P(S):F()},[S,P,F]),useMountEffect(()=>{s(l),!0!==v&&window.history.state&&window.history.state.filterBuilder?_(window.history.state,!1):S?P(S):F()}),t(n,{children:e("form",Object.assign({onSubmit:x},{children:[t(FilterGroup,{clauseId:rootGroupUuid,path:[],root:!0}),e(b,Object.assign({container:!0,spacing:1},{children:[t(b,Object.assign({item:!0},{children:e(G,Object.assign({variant:"contained",color:"primary"},{children:[t(L,Object.assign({type:"submit"},{children:"Search"})),l.searchMenuItems&&t(L,Object.assign({size:"small",onClick:e=>m(e.currentTarget),"aria-controls":null!==g?"search-menu":void 0,"aria-expanded":null!==g?"true":void 0,"aria-haspopup":"menu"},{children:t(y,{})}))]}))})),t(b,Object.assign({item:!0,id:"filter-action-btn",className:"action-buttons"},{children:t(L,Object.assign({variant:"outlined",onClick:T,className:"secondary-btn"},{children:"Reset"}))}))]})),l.searchMenuItems&&t(k,Object.assign({anchorEl:g,open:null!==g,anchorOrigin:{vertical:"bottom",horizontal:"left"},onClose:()=>m(null),transitionDuration:100},{children:t(I,{children:t(D,Object.assign({id:"search-menu"},{children:l.searchMenuItems.map((e,l)=>t(O,Object.assign({onClick:e.onClick},{children:e.label}),`searchMenu_${l}`))}))})}))]}))})},FilterBuilder=l.memo(e=>t(h,Object.assign({override:!0},{children:t(FilterRoot,{props:e})}))),defaultPageSize=10,ExpandToQuery=e=>{if(void 0===e)return"";if(!Array.isArray(e))return ExpandToQuery([e]);let t=GroupArrayBy(e,e=>e.navigationField),l=[];return t.forEach((e,t)=>{var i,o;l.push({navigationField:t,top:null===(i=e.find(e=>e.top))||void 0===i?void 0:i.top,orderBy:null===(o=e.find(e=>e.orderBy))||void 0===o?void 0:o.orderBy,count:e.some(e=>e.count),select:Array.from(new Set(e.filter(e=>e.select).map(e=>e.select))).join(","),expand:e.filter(e=>e.expand).map(e=>e.expand).reduce((e,t)=>Array.isArray(t)?e.concat(t):[...e,t],[])})}),l.map(e=>{let t=`${e.navigationField}`,l=[{type:"select",value:e.select},{type:"expand",value:ExpandToQuery(e.expand)},{type:"orderby",value:e.orderBy},{type:"top",value:e.top},{type:"count",value:e.count}];return l.some(e=>e.value)&&(t+=`(${l.filter(e=>e.value).map(e=>`$${e.type}=${e.value}`).join(";")})`),t}).join(",")},GroupArrayBy=(e,t)=>e.reduce((e,l)=>e.set(t(l),[...e.get(t(l))||[],l]),new Map),Flatten=(e,t=".")=>_flatten(e,t,""),_flatten=(e,t,l)=>Object.keys(e).reduce((i,o)=>{if(null!==e[o]){let a=l.length?l+t:"";Array.isArray(e[o])?i[a+o]=e[o].map(e=>Flatten(e,t)):"object"==typeof e[o]?Object.assign(i,_flatten(e[o],t,a+o)):i[a+o]=e[o]}return i},{}),GetPageNumber=()=>{let e=new URLSearchParams(window.location.search);if(e.has("page")){let t=e.get("page");if(t)return parseInt(t,10)-1}return 0},GetPageSizeOrDefault=e=>{let t=new URLSearchParams(window.location.search);if(t.has("page-size")){let l=t.get("page-size");if(l)return parseInt(l,10)}return null!=e?e:10},ODataGridBase=u=>{var c;let[p,g]=o(GetPageNumber()),[f,m]=o(GetPageSizeOrDefault(u.defaultPageSize)),[h,$]=o([]),[v,y]=o(0),[b,S]=o(!0),[x,C]=o(u.defaultSortModel),[T,F]=o(""),[O,_]=o(),[P,M]=o(),[B,G]=o(),[L,k]=o(u.columns.filter(e=>u.columnVisibilityModel&&!1!==u.columnVisibilityModel[e.field]||!0!==e.hide).map(e=>e.field)),[I,D]=o({}),z=s(!0),q=s(!0),w=s(!1),E=useResponsive(),A=r(()=>__awaiter(void 0,void 0,void 0,function*(){var e;if(!T&&!0!==u.disableFilterBuilder&&(null===(e=u.filterBuilderProps)||void 0===e?void 0:e.disableHistory)!==!0&&window.history.state&&window.history.state.filterBuilder&&!0!==window.history.state.filterBuilder.reset)return;S(!0);let t=new Set(u.columns.filter(e=>L.includes(e.field)&&void 0===e.expand&&!0!==e.filterOnly&&"actions"!==e.type).map(e=>{var t;return null!==(t=e.select)&&void 0!==t?t:e.field}));u.alwaysSelect&&u.alwaysSelect.forEach(e=>t.add(e)),O&&O.forEach(e=>t.add(e));let l=u.columns.filter(e=>L.includes(e.field)&&e.expand).map(e=>e.expand).reduce((e,t)=>Array.isArray(t)?e.concat(t):[...e,t],[]),i=new URLSearchParams;if(t.size>0&&i.append("$select",Array.from(t).join(",")),l.length>0&&i.append("$expand",ExpandToQuery(l)),i.append("$top",f.toString()),i.append("$skip",(p*f).toString()),q.current&&i.append("$count","true"),B)for(let o in B)i.append(o,B[o]);if(T?i.append("$filter",T):u.$filter&&i.append("$filter",u.$filter),P&&i.append("$compute",P),x&&x.length>0){let a=x.map(e=>({col:u.columns.find(t=>t.field===e.field),sort:e.sort})).filter(e=>e.col).map(e=>{var t;return`${null!==(t=e.col.sortField)&&void 0!==t?t:e.col.field}${"desc"===e.sort?" desc":""}`});a.length>0&&i.append("$orderby",a.join(","))}let n=yield fetch(u.url+"?"+i.toString(),u.requestOptions);if(n.ok){let r=yield n.json(),s=r.value.map(e=>Object.assign({result:e},Flatten(e,"/")));(r["@odata.count"]||0===r["@odata.count"])&&y(r["@odata.count"]),$(s),S(!1),z.current=!1,w.current=!1,q.current=!1}else console.error(`API request failed: ${n.url}, HTTP ${n.status}`)}),[p,f,L,x,T,O,P,B,u.url,u.alwaysSelect,u.columns,u.$filter,u.disableFilterBuilder,null===(c=u.filterBuilderProps)||void 0===c?void 0:c.disableHistory,u.requestOptions]),N=r(e=>{var t;return w.current=!0,q.current=!0,(null===(t=u.filterBuilderProps)||void 0===t?void 0:t.onSubmit)&&u.filterBuilderProps.onSubmit(e),M(e.compute),F(e.filter),_(e.select),G(e.queryString),g(0),{oDataGrid:{sortModel:x}}},[u.filterBuilderProps,x]),U=r((e,t)=>{var l,i;q.current=!0,(null===(l=u.filterBuilderProps)||void 0===l?void 0:l.onRestoreState)&&u.filterBuilderProps.onRestoreState(e,t),!0!==u.disableHistory&&((null===(i=null==t?void 0:t.oDataGrid)||void 0===i?void 0:i.sortModel)?C(t.oDataGrid.sortModel):C(u.defaultSortModel)),M(e.compute),F(e.filter),_(e.select),G(e.queryString)},[u.filterBuilderProps,u.disableHistory,u.defaultSortModel]);i(()=>{(z?.current||u.refreshData)&&A()},[A,z,u.refreshData]);let{onColumnVisibilityModelChange:j,onSortModelChange:V}=u,H=r((e,t)=>{V&&V(e,t),C(e),!0!==u.disableHistory&&window.history.pushState(Object.assign(Object.assign({},window.history.state),{oDataGrid:{sortModel:e}}),"")},[V,u.disableHistory]);i(()=>{var e,t;let l=!1,i=new URLSearchParams(window.location.search),o=i.get("page");o?parseInt(o,10)-1!==p&&(0!==p?i.set("page",(p+1).toString()):i.delete("page"),l=!0):0!==p&&(i.set("page",(p+1).toString()),l=!0);let a=i.get("page-size");if(a?parseInt(a,10)!==f&&(f!==(null!==(e=u.defaultPageSize)&&void 0!==e?e:10)?i.set("page-size",f.toString()):i.delete("page-size"),l=!0):f!==(null!==(t=u.defaultPageSize)&&void 0!==t?t:10)&&(i.set("page-size",f.toString()),l=!0),l&&!z.current){let n=i.toString(),r=n?`${window.location.pathname}?${n}${window.location.hash}`:`${window.location.pathname}${window.location.hash}`;w.current?window.history.replaceState(window.history.state,"",r):window.history.pushState(window.history.state,"",r)}},[p,f,u.defaultPageSize]),i(()=>{let e=e=>{var t,l,i,o;let a=new URLSearchParams(window.location.search),n=a.get("page");if(n){let r=parseInt(n,10)-1;g(r)}else 0!==p&&g(0);let s=a.get("page-size");if(s){let d=parseInt(s,10)-1;m(d)}else(t=f!==u.defaultPageSize)&&m(null!==(l=u.defaultPageSize)&&void 0!==l?l:10);!0!==u.disableHistory&&!0===u.disableFilterBuilder&&((null===(o=null===(i=e.state)||void 0===i?void 0:i.oDataGrid)||void 0===o?void 0:o.sortModel)?C(e.state.oDataGrid.sortModel):C(u.defaultSortModel))};return window.addEventListener("popstate",e),()=>window.removeEventListener("popstate",e)},[p,f,u.defaultPageSize,u.defaultSortModel,u.disableHistory,u.disableFilterBuilder]);let W=r(e=>{g(e)},[]),Q=r(e=>{m(e)},[]),Y=a(()=>{let e={};if(u.columnVisibilityModel)for(let t in u.columnVisibilityModel)t in I?e[t]=I[t]:"boolean"==typeof u.columnVisibilityModel[t]?e[t]=u.columnVisibilityModel[t]:e[t]=E(u.columnVisibilityModel[t]);else u.columns.filter(e=>!0!==e.filterOnly).forEach(t=>{t.field in I?e[t.field]=I[t.field]:"boolean"==typeof t.hide?e[t.field]=!t.hide:t.hide&&(e[t.field]=!E(t.hide))});return u.columns.filter(e=>!0===e.filterOnly).forEach(t=>{e[t.field]=!1}),e},[u.columnVisibilityModel,E,u.columns,I]),J=r((e,t)=>{j&&j(e,t);let l=Object.keys(e).find(t=>Y[t]!==e[t]);if(l){let i=e[l];D(e=>Object.assign(Object.assign({},e),{[l]:i})),i?k(e=>[...e,l]):k(e=>e.filter(e=>e!==l))}},[j,Y]),K=a(()=>u.columns.filter(e=>!0!==e.filterOnly),[u.columns]),X=u.component;return e(n,{children:[void 0===u.$filter&&!0!==u.disableFilterBuilder&&t(d,Object.assign({mb:2},{children:t(FilterBuilder,Object.assign({},u.filterBuilderProps,{schema:u.fixedColumns,onSubmit:N,onRestoreState:U}))})),t(X,Object.assign({autoHeight:!0,ref:l.createRef()},u,{columns:K,rows:h,rowCount:v,pagination:!0,paginationMode:"server",page:p,pageSize:f,onPageChange:W,onPageSizeChange:Q,disableColumnFilter:!0,loading:b,columnVisibilityModel:Y,onColumnVisibilityModelChange:J,sortingMode:"server",sortModel:x,onSortModelChange:H}))]})},ODataGrid=e=>t(ODataGridBase,Object.assign({},e,{component:U}));export{FilterBuilder,ODataGrid,allOperators,defaultTranslators,escapeODataString,numericOperators};
\ No newline at end of file
diff --git a/node_modules/o-data-grid/build/o-data-grid.d.ts b/node_modules/o-data-grid/build/o-data-grid.d.ts
index dfbec7e..0ca94e7 100644
--- a/node_modules/o-data-grid/build/o-data-grid.d.ts
+++ b/node_modules/o-data-grid/build/o-data-grid.d.ts
@@ -111,7 +111,7 @@ declare type FilterTranslatorParams<TDate> = {
     value: any;
 };
 declare type Connective = "and" | "or";
-declare type Operation = "eq" | "ne" | "gt" | "lt" | "ge" | "le" | "contains" | "null" | "notnull";
+export declare type Operation = "eq" | "ne" | "gt" | "lt" | "ge" | "le" | "contains" | "null" | "notnull";
 declare type CollectionOperation = "any" | "all" | "count";
 declare type Clause = {
     id: string;
@@ -135,7 +135,9 @@ declare type SerialisedCondition = Omit<ConditionClause, "id" | "default">;
 declare type ODataGridBaseProps<ComponentProps extends IGridProps, SortModel extends IGridSortModel, ColDef, TRow, TDate> = OmitGridProps<ComponentProps> & {
     url: string;
     alwaysSelect?: string[];
+    refreshData: boolean;
     columns: ODataGridBaseColDef<ColDef, TDate>[];
+    fixedColumns: ODataGridBaseColDef<ColDef, TDate>[];
     columnVisibilityModel?: ODataColumnVisibilityModel;
     component: React.ElementType;
     defaultPageSize?: number;
@@ -205,4 +207,4 @@ declare type ODataGridColDef<TRow = any, TDate = any> = ODataGridBaseColDef<Grid
 declare type ODataGridEnrichedColDef<TRow = any, V = any, F = any, TDate = any> = ODataGridBaseEnrichedColDef<GridColDef<ODataRowModel<TRow>, V, F>, GridActionsColDef<ODataRowModel<TRow>>, TDate>;
 declare type ODataGridColumns<TRow = any, TDate = any> = ODataBaseGridColumns<GridEnrichedColDef<ODataRowModel<TRow>>, GridActionsColDef<ODataRowModel<TRow>>, TDate>;
 
-export { CollectionFieldDef, CollectionOperation, ComputeSelect, Connective, ExternalBuilderProps, FieldDef, FilterBuilder, FilterBuilderLocaleText, FilterBuilderProps, FilterCompute, FilterParameters, ODataColumnVisibilityModel, ODataGrid, ODataGridColDef, ODataGridColumns, ODataGridEnrichedColDef, ODataGridProps, QueryStringCollection, SelectOption, SerialisedCondition, SerialisedGroup, ValueOption, allOperators, defaultTranslators, escapeODataString, numericOperators };
+export { CollectionFieldDef, CollectionOperation, ComputeSelect, Connective, ExternalBuilderProps, FieldDef, FilterBuilder, FilterBuilderLocaleText, FilterBuilderProps, FilterCompute, FilterParameters, ODataColumnVisibilityModel, ODataGrid, ODataGridColDef, ODataGridColumns, ODataGridEnrichedColDef, ODataGridProps, ODataRowModel, QueryStringCollection, SelectOption, SerialisedCondition, SerialisedGroup, ValueOption, allOperators, defaultTranslators, escapeODataString, numericOperators };
